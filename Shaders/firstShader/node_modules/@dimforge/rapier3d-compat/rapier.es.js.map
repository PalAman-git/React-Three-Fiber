{"version":3,"file":"rapier.es.js","sources":["rapier_wasm3d.js","../gen3d/gen3d/math.ts","../gen3d/gen3d/dynamics/rigid_body.ts","../gen3d/gen3d/dynamics/impulse_joint.ts","../gen3d/gen3d/dynamics/coefficient_combine_rule.ts","../gen3d/gen3d/geometry/feature.ts","../gen3d/gen3d/geometry/shape.ts","../gen3d/gen3d/geometry/collider.ts","../gen3d/gen3d/pipeline/query_pipeline.ts","../gen3d/gen3d/pipeline/event_queue.ts","../gen3d/gen3d/pipeline/physics_hooks.ts","../gen3d/gen3d/coarena.ts","../gen3d/gen3d/dynamics/rigid_body_set.ts","../gen3d/gen3d/dynamics/integration_parameters.ts","../gen3d/gen3d/dynamics/impulse_joint_set.ts","../gen3d/gen3d/dynamics/multibody_joint.ts","../gen3d/gen3d/dynamics/multibody_joint_set.ts","../gen3d/gen3d/dynamics/ccd_solver.ts","../gen3d/gen3d/dynamics/island_manager.ts","../gen3d/gen3d/geometry/broad_phase.ts","../gen3d/gen3d/geometry/narrow_phase.ts","../gen3d/gen3d/geometry/contact.ts","../gen3d/gen3d/geometry/point.ts","../gen3d/gen3d/geometry/ray.ts","../gen3d/gen3d/geometry/toi.ts","../gen3d/gen3d/geometry/collider_set.ts","../gen3d/gen3d/pipeline/physics_pipeline.ts","../gen3d/gen3d/pipeline/serialization_pipeline.ts","../gen3d/gen3d/pipeline/debug_render_pipeline.ts","../gen3d/gen3d/control/character_controller.ts","../gen3d/gen3d/pipeline/world.ts","../node_modules/tslib/tslib.es6.js","../node_modules/base64-js/index.js","../gen3d/gen3d/init.ts","../gen3d/gen3d/exports.ts"],"sourcesContent":["\nlet wasm;\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedFloat64Memory0 = new Float64Array();\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nlet cachedInt32Memory0 = new Int32Array();\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nconst cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = new Uint8Array();\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n/**\n* @returns {string}\n*/\nexport function version() {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.version(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(r0, r1);\n    }\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nlet cachedFloat32Memory0 = new Float32Array();\n\nfunction getFloat32Memory0() {\n    if (cachedFloat32Memory0.byteLength === 0) {\n        cachedFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32Memory0;\n}\n\nlet stack_pointer = 32;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet cachedUint32Memory0 = new Uint32Array();\n\nfunction getUint32Memory0() {\n    if (cachedUint32Memory0.byteLength === 0) {\n        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getFloat32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4);\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n*/\nexport const RawJointType = Object.freeze({ Revolute:0,\"0\":\"Revolute\",Fixed:1,\"1\":\"Fixed\",Prismatic:2,\"2\":\"Prismatic\",Spherical:3,\"3\":\"Spherical\",Generic:4,\"4\":\"Generic\", });\n/**\n*/\nexport const RawMotorModel = Object.freeze({ AccelerationBased:0,\"0\":\"AccelerationBased\",ForceBased:1,\"1\":\"ForceBased\", });\n/**\n*/\nexport const RawJointAxis = Object.freeze({ X:0,\"0\":\"X\",Y:1,\"1\":\"Y\",Z:2,\"2\":\"Z\",AngX:3,\"3\":\"AngX\",AngY:4,\"4\":\"AngY\",AngZ:5,\"5\":\"AngZ\", });\n/**\n*/\nexport const RawRigidBodyType = Object.freeze({ Dynamic:0,\"0\":\"Dynamic\",Fixed:1,\"1\":\"Fixed\",KinematicPositionBased:2,\"2\":\"KinematicPositionBased\",KinematicVelocityBased:3,\"3\":\"KinematicVelocityBased\", });\n/**\n*/\nexport const RawFeatureType = Object.freeze({ Vertex:0,\"0\":\"Vertex\",Edge:1,\"1\":\"Edge\",Face:2,\"2\":\"Face\",Unknown:3,\"3\":\"Unknown\", });\n/**\n*/\nexport const RawShapeType = Object.freeze({ Ball:0,\"0\":\"Ball\",Cuboid:1,\"1\":\"Cuboid\",Capsule:2,\"2\":\"Capsule\",Segment:3,\"3\":\"Segment\",Polyline:4,\"4\":\"Polyline\",Triangle:5,\"5\":\"Triangle\",TriMesh:6,\"6\":\"TriMesh\",HeightField:7,\"7\":\"HeightField\",Compound:8,\"8\":\"Compound\",ConvexPolyhedron:9,\"9\":\"ConvexPolyhedron\",Cylinder:10,\"10\":\"Cylinder\",Cone:11,\"11\":\"Cone\",RoundCuboid:12,\"12\":\"RoundCuboid\",RoundTriangle:13,\"13\":\"RoundTriangle\",RoundCylinder:14,\"14\":\"RoundCylinder\",RoundCone:15,\"15\":\"RoundCone\",RoundConvexPolyhedron:16,\"16\":\"RoundConvexPolyhedron\",HalfSpace:17,\"17\":\"HalfSpace\", });\n/**\n*/\nexport class RawBroadPhase {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawBroadPhase.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawbroadphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawbroadphase_new();\n        return RawBroadPhase.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawCCDSolver {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawCCDSolver.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawccdsolver_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawccdsolver_new();\n        return RawCCDSolver.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawCharacterCollision {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawCharacterCollision.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcharactercollision_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawcharactercollision_new();\n        return RawCharacterCollision.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    handle() {\n        const ret = wasm.rawcharactercollision_handle(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    translationApplied() {\n        const ret = wasm.rawcharactercollision_translationApplied(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    translationRemaining() {\n        const ret = wasm.rawcharactercollision_translationRemaining(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldWitness1() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldWitness2() {\n        const ret = wasm.rawcharactercollision_worldWitness2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldNormal1() {\n        const ret = wasm.rawcharactercollision_worldNormal1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldNormal2() {\n        const ret = wasm.rawcharactercollision_worldNormal2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawColliderSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawColliderSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcolliderset_free(ptr);\n    }\n    /**\n    * The world-space translation of this collider.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    coTranslation(handle) {\n        const ret = wasm.rawcolliderset_coTranslation(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this collider.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    coRotation(handle) {\n        const ret = wasm.rawcolliderset_coRotation(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this collider.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the collider along the `x` axis.\n    * - `y`: the world-space position of the collider along the `y` axis.\n    * - `z`: the world-space position of the collider along the `z` axis.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    coSetTranslation(handle, x, y, z) {\n        wasm.rawcolliderset_coSetTranslation(this.ptr, handle, x, y, z);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    coSetTranslationWrtParent(handle, x, y, z) {\n        wasm.rawcolliderset_coSetTranslationWrtParent(this.ptr, handle, x, y, z);\n    }\n    /**\n    * Sets the rotation quaternion of this collider.\n    *\n    * This does nothing if a zero quaternion is provided.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    coSetRotation(handle, x, y, z, w) {\n        wasm.rawcolliderset_coSetRotation(this.ptr, handle, x, y, z, w);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    coSetRotationWrtParent(handle, x, y, z, w) {\n        wasm.rawcolliderset_coSetRotationWrtParent(this.ptr, handle, x, y, z, w);\n    }\n    /**\n    * Is this collider a sensor?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    coIsSensor(handle) {\n        const ret = wasm.rawcolliderset_coIsSensor(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The type of the shape of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coShapeType(handle) {\n        const ret = wasm.rawcolliderset_coShapeType(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHalfspaceNormal(handle) {\n        const ret = wasm.rawcolliderset_coHalfspaceNormal(this.ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The half-extents of this collider if it is has a cuboid shape.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHalfExtents(handle) {\n        const ret = wasm.rawcolliderset_coHalfExtents(this.ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * Set the half-extents of this collider if it has a cuboid shape.\n    * @param {number} handle\n    * @param {RawVector} newHalfExtents\n    */\n    coSetHalfExtents(handle, newHalfExtents) {\n        _assertClass(newHalfExtents, RawVector);\n        wasm.rawcolliderset_coSetHalfExtents(this.ptr, handle, newHalfExtents.ptr);\n    }\n    /**\n    * The radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRadius(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @param {number} newRadius\n    */\n    coSetRadius(handle, newRadius) {\n        wasm.rawcolliderset_coSetRadius(this.ptr, handle, newRadius);\n    }\n    /**\n    * The half height of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHalfHeight(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHalfHeight(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the half height of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @param {number} newHalfheight\n    */\n    coSetHalfHeight(handle, newHalfheight) {\n        wasm.rawcolliderset_coSetHalfHeight(this.ptr, handle, newHalfheight);\n    }\n    /**\n    * The radius of the round edges of this collider.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRoundRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRoundRadius(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the radius of the round edges of this collider.\n    * @param {number} handle\n    * @param {number} newBorderRadius\n    */\n    coSetRoundRadius(handle, newBorderRadius) {\n        wasm.rawcolliderset_coSetRoundRadius(this.ptr, handle, newBorderRadius);\n    }\n    /**\n    * The vertices of this triangle mesh, polyline, convex polyhedron, segment, triangle or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coVertices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coVertices(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The indices of this triangle mesh, polyline, or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Uint32Array | undefined}\n    */\n    coIndices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coIndices(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayU32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The height of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coHeightfieldHeights(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldHeights(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v0;\n            if (r0 !== 0) {\n                v0 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4);\n            }\n            return v0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The scaling factor applied of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHeightfieldScale(handle) {\n        const ret = wasm.rawcolliderset_coHeightfieldScale(this.ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The number of rows on this heightfield's height matrix, if it is one.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHeightfieldNRows(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldNRows(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The number of columns on this heightfield's height matrix, if it is one.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHeightfieldNCols(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldNCols(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The unique integer identifier of the collider this collider is attached to.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coParent(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coParent(retptr, this.ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    coSetEnabled(handle, enabled) {\n        wasm.rawcolliderset_coSetEnabled(this.ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    coIsEnabled(handle) {\n        const ret = wasm.rawcolliderset_coIsEnabled(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The friction coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFriction(handle) {\n        const ret = wasm.rawcolliderset_coFriction(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The restitution coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitution(handle) {\n        const ret = wasm.rawcolliderset_coRestitution(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The density of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coDensity(handle) {\n        const ret = wasm.rawcolliderset_coDensity(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The mass of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coMass(handle) {\n        const ret = wasm.rawcolliderset_coMass(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The volume of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coVolume(handle) {\n        const ret = wasm.rawcolliderset_coVolume(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The collision groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coCollisionGroups(handle) {\n        const ret = wasm.rawcolliderset_coCollisionGroups(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The solver groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coSolverGroups(handle) {\n        const ret = wasm.rawcolliderset_coSolverGroups(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The physics hooks enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveHooks(handle) {\n        const ret = wasm.rawcolliderset_coActiveHooks(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The collision types enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveCollisionTypes(handle) {\n        const ret = wasm.rawcolliderset_coActiveCollisionTypes(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The events enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveEvents(handle) {\n        const ret = wasm.rawcolliderset_coActiveEvents(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The total force magnitude beyond which a contact force event can be emitted.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coContactForceEventThreshold(handle) {\n        const ret = wasm.rawcolliderset_coContactForceEventThreshold(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n    coContainsPoint(handle, point) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coContainsPoint(this.ptr, handle, point.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} colliderVel\n    * @param {RawShape} shape2\n    * @param {RawVector} shape2Pos\n    * @param {RawRotation} shape2Rot\n    * @param {RawVector} shape2Vel\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeTOI | undefined}\n    */\n    coCastShape(handle, colliderVel, shape2, shape2Pos, shape2Rot, shape2Vel, maxToi, stop_at_penetration) {\n        _assertClass(colliderVel, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shape2Pos, RawVector);\n        _assertClass(shape2Rot, RawRotation);\n        _assertClass(shape2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastShape(this.ptr, handle, colliderVel.ptr, shape2.ptr, shape2Pos.ptr, shape2Rot.ptr, shape2Vel.ptr, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeTOI.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} collider1Vel\n    * @param {number} collider2handle\n    * @param {RawVector} collider2Vel\n    * @param {number} max_toi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeColliderTOI | undefined}\n    */\n    coCastCollider(handle, collider1Vel, collider2handle, collider2Vel, max_toi, stop_at_penetration) {\n        _assertClass(collider1Vel, RawVector);\n        _assertClass(collider2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastCollider(this.ptr, handle, collider1Vel.ptr, collider2handle, collider2Vel.ptr, max_toi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeColliderTOI.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n    coIntersectsShape(handle, shape2, shapePos2, shapeRot2) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coIntersectsShape(this.ptr, handle, shape2.ptr, shapePos2.ptr, shapeRot2.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    coContactShape(handle, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coContactShape(this.ptr, handle, shape2.ptr, shapePos2.ptr, shapeRot2.ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} collider2handle\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    coContactCollider(handle, collider2handle, prediction) {\n        const ret = wasm.rawcolliderset_coContactCollider(this.ptr, handle, collider2handle, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n    coProjectPoint(handle, point, solid) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coProjectPoint(this.ptr, handle, point.ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n    coIntersectsRay(handle, rayOrig, rayDir, maxToi) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coIntersectsRay(this.ptr, handle, rayOrig.ptr, rayDir.ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n    coCastRay(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRay(this.ptr, handle, rayOrig.ptr, rayDir.ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n    coCastRayAndGetNormal(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRayAndGetNormal(this.ptr, handle, rayOrig.ptr, rayDir.ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} is_sensor\n    */\n    coSetSensor(handle, is_sensor) {\n        wasm.rawcolliderset_coSetSensor(this.ptr, handle, is_sensor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} restitution\n    */\n    coSetRestitution(handle, restitution) {\n        wasm.rawcolliderset_coSetRestitution(this.ptr, handle, restitution);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} friction\n    */\n    coSetFriction(handle, friction) {\n        wasm.rawcolliderset_coSetFriction(this.ptr, handle, friction);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFrictionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coFrictionCombineRule(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetFrictionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetFrictionCombineRule(this.ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitutionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coRestitutionCombineRule(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetRestitutionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetRestitutionCombineRule(this.ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetCollisionGroups(handle, groups) {\n        wasm.rawcolliderset_coSetCollisionGroups(this.ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetSolverGroups(handle, groups) {\n        wasm.rawcolliderset_coSetSolverGroups(this.ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} hooks\n    */\n    coSetActiveHooks(handle, hooks) {\n        wasm.rawcolliderset_coSetActiveHooks(this.ptr, handle, hooks);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} events\n    */\n    coSetActiveEvents(handle, events) {\n        wasm.rawcolliderset_coSetActiveEvents(this.ptr, handle, events);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} types\n    */\n    coSetActiveCollisionTypes(handle, types) {\n        wasm.rawcolliderset_coSetActiveCollisionTypes(this.ptr, handle, types);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape\n    */\n    coSetShape(handle, shape) {\n        _assertClass(shape, RawShape);\n        wasm.rawcolliderset_coSetShape(this.ptr, handle, shape.ptr);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} threshold\n    */\n    coSetContactForceEventThreshold(handle, threshold) {\n        wasm.rawcolliderset_coSetContactForceEventThreshold(this.ptr, handle, threshold);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} density\n    */\n    coSetDensity(handle, density) {\n        wasm.rawcolliderset_coSetDensity(this.ptr, handle, density);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    */\n    coSetMass(handle, mass) {\n        wasm.rawcolliderset_coSetMass(this.ptr, handle, mass);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    */\n    coSetMassProperties(handle, mass, centerOfMass, principalAngularInertia, angularInertiaFrame) {\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        wasm.rawcolliderset_coSetMassProperties(this.ptr, handle, mass, centerOfMass.ptr, principalAngularInertia.ptr, angularInertiaFrame.ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawcolliderset_new();\n        return RawColliderSet.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawcolliderset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {boolean} enabled\n    * @param {RawShape} shape\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} massPropsMode\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {number} density\n    * @param {number} friction\n    * @param {number} restitution\n    * @param {number} frictionCombineRule\n    * @param {number} restitutionCombineRule\n    * @param {boolean} isSensor\n    * @param {number} collisionGroups\n    * @param {number} solverGroups\n    * @param {number} activeCollisionTypes\n    * @param {number} activeHooks\n    * @param {number} activeEvents\n    * @param {number} contactForceEventThreshold\n    * @param {boolean} hasParent\n    * @param {number} parent\n    * @param {RawRigidBodySet} bodies\n    * @returns {number | undefined}\n    */\n    createCollider(enabled, shape, translation, rotation, massPropsMode, mass, centerOfMass, principalAngularInertia, angularInertiaFrame, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, hasParent, parent, bodies) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(shape, RawShape);\n            _assertClass(translation, RawVector);\n            _assertClass(rotation, RawRotation);\n            _assertClass(centerOfMass, RawVector);\n            _assertClass(principalAngularInertia, RawVector);\n            _assertClass(angularInertiaFrame, RawRotation);\n            _assertClass(bodies, RawRigidBodySet);\n            wasm.rawcolliderset_createCollider(retptr, this.ptr, enabled, shape.ptr, translation.ptr, rotation.ptr, massPropsMode, mass, centerOfMass.ptr, principalAngularInertia.ptr, angularInertiaFrame.ptr, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, hasParent, parent, bodies.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Removes a collider from this set and wake-up the rigid-body it is attached to.\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawRigidBodySet} bodies\n    * @param {boolean} wakeUp\n    */\n    remove(handle, islands, bodies, wakeUp) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(bodies, RawRigidBodySet);\n        wasm.rawcolliderset_remove(this.ptr, handle, islands.ptr, bodies.ptr, wakeUp);\n    }\n    /**\n    * Checks if a collider with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    isHandleValid(handle) {\n        const ret = wasm.rawcolliderset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each collider managed by this collider set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each collider managed by this collider set. Called as `f(handle)`.\n    * @param {Function} f\n    */\n    forEachColliderHandle(f) {\n        try {\n            wasm.rawcolliderset_forEachColliderHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawContactForceEvent {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawContactForceEvent.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactforceevent_free(ptr);\n    }\n    /**\n    * The first collider involved in the contact.\n    * @returns {number}\n    */\n    collider1() {\n        const ret = wasm.rawcharactercollision_handle(this.ptr);\n        return ret;\n    }\n    /**\n    * The second collider involved in the contact.\n    * @returns {number}\n    */\n    collider2() {\n        const ret = wasm.rawcontactforceevent_collider2(this.ptr);\n        return ret;\n    }\n    /**\n    * The sum of all the forces between the two colliders.\n    * @returns {RawVector}\n    */\n    total_force() {\n        const ret = wasm.rawcontactforceevent_total_force(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The sum of the magnitudes of each force between the two colliders.\n    *\n    * Note that this is **not** the same as the magnitude of `self.total_force`.\n    * Here we are summing the magnitude of all the forces, instead of taking\n    * the magnitude of their sum.\n    * @returns {number}\n    */\n    total_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.ptr);\n        return ret;\n    }\n    /**\n    * The world-space (unit) direction of the force with strongest magnitude.\n    * @returns {RawVector}\n    */\n    max_force_direction() {\n        const ret = wasm.rawcontactforceevent_max_force_direction(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The magnitude of the largest force at a contact point of this contact pair.\n    * @returns {number}\n    */\n    max_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_max_force_magnitude(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawContactManifold {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawContactManifold.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactmanifold_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawcontactmanifold_normal(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n1() {\n        const ret = wasm.rawcontactmanifold_local_n1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n2() {\n        const ret = wasm.rawcontactmanifold_local_n2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    subshape1() {\n        const ret = wasm.rawcontactmanifold_subshape1(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    subshape2() {\n        const ret = wasm.rawcontactmanifold_subshape2(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    num_contacts() {\n        const ret = wasm.rawcontactmanifold_num_contacts(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p1(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p1(this.ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p2(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p2(this.ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_contact_dist(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid1(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid1(this.ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid2(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid2(this.ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_impulse(i) {\n        const ret = wasm.rawcontactmanifold_contact_impulse(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_tangent_impulse_x(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse_x(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_tangent_impulse_y(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse_y(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    num_solver_contacts() {\n        const ret = wasm.rawcontactmanifold_num_solver_contacts(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    solver_contact_point(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_point(this.ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_dist(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_friction(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_friction(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_restitution(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_restitution(this.ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector}\n    */\n    solver_contact_tangent_velocity(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_tangent_velocity(this.ptr, i);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawContactPair {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawContactPair.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactpair_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    collider1() {\n        const ret = wasm.rawcontactpair_collider1(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    collider2() {\n        const ret = wasm.rawcontactpair_collider2(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    numContactManifolds() {\n        const ret = wasm.rawcontactpair_numContactManifolds(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawContactManifold | undefined}\n    */\n    contactManifold(i) {\n        const ret = wasm.rawcontactpair_contactManifold(this.ptr, i);\n        return ret === 0 ? undefined : RawContactManifold.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawDebugRenderPipeline {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawDebugRenderPipeline.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdebugrenderpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawdebugrenderpipeline_new();\n        return RawDebugRenderPipeline.__wrap(ret);\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    vertices() {\n        const ret = wasm.rawdebugrenderpipeline_vertices(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    colors() {\n        const ret = wasm.rawdebugrenderpipeline_colors(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @param {RawNarrowPhase} narrow_phase\n    */\n    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        _assertClass(narrow_phase, RawNarrowPhase);\n        wasm.rawdebugrenderpipeline_render(this.ptr, bodies.ptr, colliders.ptr, impulse_joints.ptr, multibody_joints.ptr, narrow_phase.ptr);\n    }\n}\n/**\n*/\nexport class RawDeserializedWorld {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawDeserializedWorld.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdeserializedworld_free(ptr);\n    }\n    /**\n    * @returns {RawVector | undefined}\n    */\n    takeGravity() {\n        const ret = wasm.rawdeserializedworld_takeGravity(this.ptr);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawIntegrationParameters | undefined}\n    */\n    takeIntegrationParameters() {\n        const ret = wasm.rawdeserializedworld_takeIntegrationParameters(this.ptr);\n        return ret === 0 ? undefined : RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n    * @returns {RawIslandManager | undefined}\n    */\n    takeIslandManager() {\n        const ret = wasm.rawdeserializedworld_takeIslandManager(this.ptr);\n        return ret === 0 ? undefined : RawIslandManager.__wrap(ret);\n    }\n    /**\n    * @returns {RawBroadPhase | undefined}\n    */\n    takeBroadPhase() {\n        const ret = wasm.rawdeserializedworld_takeBroadPhase(this.ptr);\n        return ret === 0 ? undefined : RawBroadPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawNarrowPhase | undefined}\n    */\n    takeNarrowPhase() {\n        const ret = wasm.rawdeserializedworld_takeNarrowPhase(this.ptr);\n        return ret === 0 ? undefined : RawNarrowPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawRigidBodySet | undefined}\n    */\n    takeBodies() {\n        const ret = wasm.rawdeserializedworld_takeBodies(this.ptr);\n        return ret === 0 ? undefined : RawRigidBodySet.__wrap(ret);\n    }\n    /**\n    * @returns {RawColliderSet | undefined}\n    */\n    takeColliders() {\n        const ret = wasm.rawdeserializedworld_takeColliders(this.ptr);\n        return ret === 0 ? undefined : RawColliderSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawImpulseJointSet | undefined}\n    */\n    takeImpulseJoints() {\n        const ret = wasm.rawdeserializedworld_takeImpulseJoints(this.ptr);\n        return ret === 0 ? undefined : RawImpulseJointSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawMultibodyJointSet | undefined}\n    */\n    takeMultibodyJoints() {\n        const ret = wasm.rawdeserializedworld_takeMultibodyJoints(this.ptr);\n        return ret === 0 ? undefined : RawMultibodyJointSet.__wrap(ret);\n    }\n}\n/**\n* A structure responsible for collecting events generated\n* by the physics engine.\n*/\nexport class RawEventQueue {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawEventQueue.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_raweventqueue_free(ptr);\n    }\n    /**\n    * Creates a new event collector.\n    *\n    * # Parameters\n    * - `autoDrain`: setting this to `true` is strongly recommended. If true, the collector will\n    * be automatically drained before each `world.step(collector)`. If false, the collector will\n    * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n    * RAM if no drain is performed.\n    * @param {boolean} autoDrain\n    */\n    constructor(autoDrain) {\n        const ret = wasm.raweventqueue_new(autoDrain);\n        return RawEventQueue.__wrap(ret);\n    }\n    /**\n    * Applies the given javascript closure on each collision event of this collector, then clear\n    * the internal collision event buffer.\n    *\n    * # Parameters\n    * - `f(handle1, handle2, started)`:  JavaScript closure applied to each collision event. The\n    * closure should take three arguments: two integers representing the handles of the colliders\n    * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n    * (false).\n    * @param {Function} f\n    */\n    drainCollisionEvents(f) {\n        try {\n            wasm.raweventqueue_drainCollisionEvents(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {Function} f\n    */\n    drainContactForceEvents(f) {\n        try {\n            wasm.raweventqueue_drainContactForceEvents(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Removes all events contained by this collector.\n    */\n    clear() {\n        wasm.raweventqueue_clear(this.ptr);\n    }\n}\n/**\n*/\nexport class RawGenericJoint {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawGenericJoint.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawgenericjoint_free(ptr);\n    }\n    /**\n    * Create a new joint descriptor that builds spehrical joints.\n    *\n    * A spherical joints allows three relative rotational degrees of freedom\n    * by preventing any relative translation between the anchors of the\n    * two attached rigid-bodies.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint}\n    */\n    static spherical(anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_spherical(anchor1.ptr, anchor2.ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Prismatic joint.\n    *\n    * A prismatic joint removes all the degrees of freedom between the\n    * affected bodies, except for the translation along one axis.\n    *\n    * Returns `None` if any of the provided axes cannot be normalized.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @param {boolean} limitsEnabled\n    * @param {number} limitsMin\n    * @param {number} limitsMax\n    * @returns {RawGenericJoint | undefined}\n    */\n    static prismatic(anchor1, anchor2, axis, limitsEnabled, limitsMin, limitsMax) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_prismatic(anchor1.ptr, anchor2.ptr, axis.ptr, limitsEnabled, limitsMin, limitsMax);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Fixed joint.\n    *\n    * A fixed joint removes all the degrees of freedom between the affected bodies.\n    * @param {RawVector} anchor1\n    * @param {RawRotation} axes1\n    * @param {RawVector} anchor2\n    * @param {RawRotation} axes2\n    * @returns {RawGenericJoint}\n    */\n    static fixed(anchor1, axes1, anchor2, axes2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(axes1, RawRotation);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axes2, RawRotation);\n        const ret = wasm.rawgenericjoint_fixed(anchor1.ptr, axes1.ptr, anchor2.ptr, axes2.ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Create a new joint descriptor that builds Revolute joints.\n    *\n    * A revolute joint removes all degrees of freedom between the affected\n    * bodies except for the rotation along one axis.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @returns {RawGenericJoint | undefined}\n    */\n    static revolute(anchor1, anchor2, axis) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_revolute(anchor1.ptr, anchor2.ptr, axis.ptr);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawImpulseJointSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawImpulseJointSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawimpulsejointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointType(handle) {\n        const ret = wasm.rawimpulsejointset_jointType(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The unique integer identifier of the first rigid-body this joint it attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle1(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle1(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The unique integer identifier of the second rigid-body this joint is attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle2(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle2(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular part of the joints local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX1(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joints local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX2(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor1(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor2(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Sets the position of the first local anchor\n    * @param {number} handle\n    * @param {RawVector} newPos\n    */\n    jointSetAnchor1(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor1(this.ptr, handle, newPos.ptr);\n    }\n    /**\n    * Sets the position of the second local anchor\n    * @param {number} handle\n    * @param {RawVector} newPos\n    */\n    jointSetAnchor2(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor2(this.ptr, handle, newPos.ptr);\n    }\n    /**\n    * Are contacts between the rigid-bodies attached by this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawimpulsejointset_jointContactsEnabled(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawimpulsejointset_jointSetContactsEnabled(this.ptr, handle, enabled);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsEnabled(this.ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {number}\n    */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMin(this.ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {number}\n    */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMax(this.ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * Enables and sets the joint limits\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} min\n    * @param {number} max\n    */\n    jointSetLimits(handle, axis, min, max) {\n        wasm.rawimpulsejointset_jointSetLimits(this.ptr, handle, axis, min, max);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} model\n    */\n    jointConfigureMotorModel(handle, axis, model) {\n        wasm.rawimpulsejointset_jointConfigureMotorModel(this.ptr, handle, axis, model);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} targetVel\n    * @param {number} factor\n    */\n    jointConfigureMotorVelocity(handle, axis, targetVel, factor) {\n        wasm.rawimpulsejointset_jointConfigureMotorVelocity(this.ptr, handle, axis, targetVel, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} targetPos\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureMotorPosition(handle, axis, targetPos, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotorPosition(this.ptr, handle, axis, targetPos, stiffness, damping);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} axis\n    * @param {number} targetPos\n    * @param {number} targetVel\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureMotor(handle, axis, targetPos, targetVel, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotor(this.ptr, handle, axis, targetPos, targetVel, stiffness, damping);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawimpulsejointset_new();\n        return RawImpulseJointSet.__wrap(ret);\n    }\n    /**\n    * @param {RawGenericJoint} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @param {boolean} wake_up\n    * @returns {number}\n    */\n    createJoint(params, parent1, parent2, wake_up) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawimpulsejointset_createJoint(this.ptr, params.ptr, parent1, parent2, wake_up);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    remove(handle, wakeUp) {\n        wasm.rawimpulsejointset_remove(this.ptr, handle, wakeUp);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawimpulsejointset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawimpulsejointset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointAttachedToRigidBody(this.ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawIntegrationParameters {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawIntegrationParameters.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawintegrationparameters_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawintegrationparameters_new();\n        return RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    get dt() {\n        const ret = wasm.rawintegrationparameters_dt(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get erp() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get allowedLinearError() {\n        const ret = wasm.rawintegrationparameters_allowedLinearError(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get predictionDistance() {\n        const ret = wasm.rawintegrationparameters_predictionDistance(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxVelocityIterations() {\n        const ret = wasm.rawintegrationparameters_maxVelocityIterations(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxVelocityFrictionIterations() {\n        const ret = wasm.rawintegrationparameters_maxVelocityFrictionIterations(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxStabilizationIterations() {\n        const ret = wasm.rawintegrationparameters_maxStabilizationIterations(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get minIslandSize() {\n        const ret = wasm.rawintegrationparameters_minIslandSize(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxCcdSubsteps() {\n        const ret = wasm.rawintegrationparameters_maxCcdSubsteps(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} value\n    */\n    set dt(value) {\n        wasm.rawintegrationparameters_set_dt(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set erp(value) {\n        wasm.rawintegrationparameters_set_erp(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set allowedLinearError(value) {\n        wasm.rawintegrationparameters_set_allowedLinearError(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set predictionDistance(value) {\n        wasm.rawintegrationparameters_set_predictionDistance(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxVelocityIterations(value) {\n        wasm.rawintegrationparameters_set_maxVelocityIterations(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxVelocityFrictionIterations(value) {\n        wasm.rawintegrationparameters_set_maxVelocityFrictionIterations(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxStabilizationIterations(value) {\n        wasm.rawintegrationparameters_set_maxStabilizationIterations(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set minIslandSize(value) {\n        wasm.rawintegrationparameters_set_minIslandSize(this.ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxCcdSubsteps(value) {\n        wasm.rawintegrationparameters_set_maxCcdSubsteps(this.ptr, value);\n    }\n}\n/**\n*/\nexport class RawIslandManager {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawIslandManager.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawislandmanager_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawislandmanager_new();\n        return RawIslandManager.__wrap(ret);\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each active rigid-body\n    * managed by this island manager.\n    *\n    * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n    * the physics engine in order to save computational power. A sleeping rigid-body never moves\n    * unless it is moved manually by the user.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each active rigid-body managed by this\n    *   set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachActiveRigidBodyHandle(f) {\n        try {\n            wasm.rawislandmanager_forEachActiveRigidBodyHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawKinematicCharacterController {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawKinematicCharacterController.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawkinematiccharactercontroller_free(ptr);\n    }\n    /**\n    * @param {number} offset\n    */\n    constructor(offset) {\n        const ret = wasm.rawkinematiccharactercontroller_new(offset);\n        return RawKinematicCharacterController.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    up() {\n        const ret = wasm.rawkinematiccharactercontroller_up(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} vector\n    */\n    setUp(vector) {\n        _assertClass(vector, RawVector);\n        wasm.rawkinematiccharactercontroller_setUp(this.ptr, vector.ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    offset() {\n        const ret = wasm.rawkinematiccharactercontroller_offset(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} value\n    */\n    setOffset(value) {\n        wasm.rawkinematiccharactercontroller_setOffset(this.ptr, value);\n    }\n    /**\n    * @returns {boolean}\n    */\n    slideEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_slideEnabled(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {boolean} enabled\n    */\n    setSlideEnabled(enabled) {\n        wasm.rawkinematiccharactercontroller_setSlideEnabled(this.ptr, enabled);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    autostepMaxHeight() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_autostepMaxHeight(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    autostepMinWidth() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_autostepMinWidth(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {boolean | undefined}\n    */\n    autostepIncludesDynamicBodies() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepIncludesDynamicBodies(this.ptr);\n        return ret === 0xFFFFFF ? undefined : ret !== 0;\n    }\n    /**\n    * @returns {boolean}\n    */\n    autostepEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepEnabled(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} maxHeight\n    * @param {number} minWidth\n    * @param {boolean} includeDynamicBodies\n    */\n    enableAutostep(maxHeight, minWidth, includeDynamicBodies) {\n        wasm.rawkinematiccharactercontroller_enableAutostep(this.ptr, maxHeight, minWidth, includeDynamicBodies);\n    }\n    /**\n    */\n    disableAutostep() {\n        wasm.rawkinematiccharactercontroller_disableAutostep(this.ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    maxSlopeClimbAngle() {\n        const ret = wasm.rawkinematiccharactercontroller_maxSlopeClimbAngle(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} angle\n    */\n    setMaxSlopeClimbAngle(angle) {\n        wasm.rawkinematiccharactercontroller_setMaxSlopeClimbAngle(this.ptr, angle);\n    }\n    /**\n    * @returns {number}\n    */\n    minSlopeSlideAngle() {\n        const ret = wasm.rawkinematiccharactercontroller_minSlopeSlideAngle(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {number} angle\n    */\n    setMinSlopeSlideAngle(angle) {\n        wasm.rawkinematiccharactercontroller_setMinSlopeSlideAngle(this.ptr, angle);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    snapToGroundDistance() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_snapToGroundDistance(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} distance\n    */\n    enableSnapToGround(distance) {\n        wasm.rawkinematiccharactercontroller_enableSnapToGround(this.ptr, distance);\n    }\n    /**\n    */\n    disableSnapToGround() {\n        wasm.rawkinematiccharactercontroller_disableSnapToGround(this.ptr);\n    }\n    /**\n    * @returns {boolean}\n    */\n    snapToGroundEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_snapToGroundEnabled(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} dt\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawQueryPipeline} queries\n    * @param {number} collider_handle\n    * @param {RawVector} desired_translation\n    * @param {boolean} apply_impulses_to_dynamic_bodies\n    * @param {number | undefined} character_mass\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {Function} filter_predicate\n    */\n    computeColliderMovement(dt, bodies, colliders, queries, collider_handle, desired_translation, apply_impulses_to_dynamic_bodies, character_mass, filter_flags, filter_groups, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(queries, RawQueryPipeline);\n            _assertClass(desired_translation, RawVector);\n            wasm.rawkinematiccharactercontroller_computeColliderMovement(this.ptr, dt, bodies.ptr, colliders.ptr, queries.ptr, collider_handle, desired_translation.ptr, apply_impulses_to_dynamic_bodies, !isLikeNone(character_mass), isLikeNone(character_mass) ? 0 : character_mass, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @returns {RawVector}\n    */\n    computedMovement() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    computedGrounded() {\n        const ret = wasm.rawkinematiccharactercontroller_computedGrounded(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {number}\n    */\n    numComputedCollisions() {\n        const ret = wasm.rawkinematiccharactercontroller_numComputedCollisions(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @param {RawCharacterCollision} collision\n    * @returns {boolean}\n    */\n    computedCollision(i, collision) {\n        _assertClass(collision, RawCharacterCollision);\n        const ret = wasm.rawkinematiccharactercontroller_computedCollision(this.ptr, i, collision.ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawMultibodyJointSet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawMultibodyJointSet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawmultibodyjointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointType(handle) {\n        const ret = wasm.rawmultibodyjointset_jointType(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The angular part of the joints local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX1(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joints local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX2(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor1(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor2(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Are contacts between the rigid-bodies attached by this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawmultibodyjointset_jointContactsEnabled(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawmultibodyjointset_jointSetContactsEnabled(this.ptr, handle, enabled);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsEnabled(this.ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {number}\n    */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMin(this.ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {number} axis\n    * @returns {number}\n    */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMax(this.ptr, handle, axis);\n        return ret;\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawmultibodyjointset_new();\n        return RawMultibodyJointSet.__wrap(ret);\n    }\n    /**\n    * @param {RawGenericJoint} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @param {boolean} wakeUp\n    * @returns {number}\n    */\n    createJoint(params, parent1, parent2, wakeUp) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawmultibodyjointset_createJoint(this.ptr, params.ptr, parent1, parent2, wakeUp);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    remove(handle, wakeUp) {\n        wasm.rawmultibodyjointset_remove(this.ptr, handle, wakeUp);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawmultibodyjointset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointAttachedToRigidBody(this.ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawNarrowPhase {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawNarrowPhase.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawnarrowphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawnarrowphase_new();\n        return RawNarrowPhase.__wrap(ret);\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    contacts_with(handle1, f) {\n        wasm.rawnarrowphase_contacts_with(this.ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {RawContactPair | undefined}\n    */\n    contact_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_contact_pair(this.ptr, handle1, handle2);\n        return ret === 0 ? undefined : RawContactPair.__wrap(ret);\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    intersections_with(handle1, f) {\n        wasm.rawnarrowphase_intersections_with(this.ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {boolean}\n    */\n    intersection_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_intersection_pair(this.ptr, handle1, handle2);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawPhysicsPipeline {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawPhysicsPipeline.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawphysicspipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawphysicspipeline_new();\n        return RawPhysicsPipeline.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    */\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        wasm.rawphysicspipeline_step(this.ptr, gravity.ptr, integrationParameters.ptr, islands.ptr, broadPhase.ptr, narrowPhase.ptr, bodies.ptr, colliders.ptr, joints.ptr, articulations.ptr, ccd_solver.ptr);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    * @param {RawEventQueue} eventQueue\n    * @param {object} hookObject\n    * @param {Function} hookFilterContactPair\n    * @param {Function} hookFilterIntersectionPair\n    */\n    stepWithEvents(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver, eventQueue, hookObject, hookFilterContactPair, hookFilterIntersectionPair) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        _assertClass(eventQueue, RawEventQueue);\n        wasm.rawphysicspipeline_stepWithEvents(this.ptr, gravity.ptr, integrationParameters.ptr, islands.ptr, broadPhase.ptr, narrowPhase.ptr, bodies.ptr, colliders.ptr, joints.ptr, articulations.ptr, ccd_solver.ptr, eventQueue.ptr, addHeapObject(hookObject), addHeapObject(hookFilterContactPair), addHeapObject(hookFilterIntersectionPair));\n    }\n}\n/**\n*/\nexport class RawPointColliderProjection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawPointColliderProjection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointcolliderprojection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        const ret = wasm.rawkinematiccharactercontroller_computedGrounded(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {number}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawPointProjection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawPointProjection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointprojection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        const ret = wasm.rawkinematiccharactercontroller_computedGrounded(this.ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawQueryPipeline {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawQueryPipeline.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawquerypipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawquerypipeline_new();\n        return RawQueryPipeline.__wrap(ret);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    */\n    update(bodies, colliders) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawquerypipeline_update(this.ptr, bodies.ptr, colliders.ptr);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawRayColliderToi | undefined}\n    */\n    castRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRay(this.ptr, bodies.ptr, colliders.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderToi.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawRayColliderIntersection | undefined}\n    */\n    castRayAndGetNormal(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRayAndGetNormal(this.ptr, bodies.ptr, colliders.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderIntersection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            wasm.rawquerypipeline_intersectionsWithRay(this.ptr, bodies.ptr, colliders.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {number | undefined}\n    */\n    intersectionWithShape(bodies, colliders, shapePos, shapeRot, shape, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionWithShape(retptr, this.ptr, bodies.ptr, colliders.ptr, shapePos.ptr, shapeRot.ptr, shape.ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPoint(bodies, colliders, point, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPoint(this.ptr, bodies.ptr, colliders.ptr, point.ptr, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPointAndGetFeature(bodies, colliders, point, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPointAndGetFeature(this.ptr, bodies.ptr, colliders.ptr, point.ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithPoint(bodies, colliders, point, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            wasm.rawquerypipeline_intersectionsWithPoint(this.ptr, bodies.ptr, colliders.ptr, point.ptr, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} shapeVel\n    * @param {RawShape} shape\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawShapeColliderTOI | undefined}\n    */\n    castShape(bodies, colliders, shapePos, shapeRot, shapeVel, shape, maxToi, stop_at_penetration, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shapeVel, RawVector);\n            _assertClass(shape, RawShape);\n            const ret = wasm.rawquerypipeline_castShape(this.ptr, bodies.ptr, colliders.ptr, shapePos.ptr, shapeRot.ptr, shapeVel.ptr, shape.ptr, maxToi, stop_at_penetration, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawShapeColliderTOI.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithShape(bodies, colliders, shapePos, shapeRot, shape, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionsWithShape(this.ptr, bodies.ptr, colliders.ptr, shapePos.ptr, shapeRot.ptr, shape.ptr, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawVector} aabbCenter\n    * @param {RawVector} aabbHalfExtents\n    * @param {Function} callback\n    */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        try {\n            _assertClass(aabbCenter, RawVector);\n            _assertClass(aabbHalfExtents, RawVector);\n            wasm.rawquerypipeline_collidersWithAabbIntersectingAabb(this.ptr, aabbCenter.ptr, aabbHalfExtents.ptr, addBorrowedObject(callback));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawRayColliderIntersection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRayColliderIntersection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycolliderintersection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcharactercollision_handle(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawraycolliderintersection_normal(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawraycolliderintersection_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    featureType() {\n        const ret = wasm.rawraycolliderintersection_featureType(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawraycolliderintersection_featureId(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawRayColliderToi {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRayColliderToi.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycollidertoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcharactercollision_handle(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawRayIntersection {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRayIntersection.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrayintersection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    featureType() {\n        const ret = wasm.rawrayintersection_featureType(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawrayintersection_featureId(retptr, this.ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawRigidBodySet {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRigidBodySet.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrigidbodyset_free(ptr);\n    }\n    /**\n    * The world-space translation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbTranslation(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbRotation(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Put the given rigid-body to sleep.\n    * @param {number} handle\n    */\n    rbSleep(handle) {\n        wasm.rawrigidbodyset_rbSleep(this.ptr, handle);\n    }\n    /**\n    * Is this rigid-body sleeping?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsSleeping(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsSleeping(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is the velocity of this rigid-body not zero?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsMoving(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsMoving(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The world-space predicted translation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbNextTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextTranslation(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space predicted orientation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbNextRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextRotation(this.ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this rigid-body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * - `z`: the world-space position of the rigid-body along the `z` axis.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {boolean} wakeUp\n    */\n    rbSetTranslation(handle, x, y, z, wakeUp) {\n        wasm.rawrigidbodyset_rbSetTranslation(this.ptr, handle, x, y, z, wakeUp);\n    }\n    /**\n    * Sets the rotation quaternion of this rigid-body.\n    *\n    * This does nothing if a zero quaternion is provided.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    * @param {boolean} wakeUp\n    */\n    rbSetRotation(handle, x, y, z, w, wakeUp) {\n        wasm.rawrigidbodyset_rbSetRotation(this.ptr, handle, x, y, z, w, wakeUp);\n    }\n    /**\n    * Sets the linear velocity of this rigid-body.\n    * @param {number} handle\n    * @param {RawVector} linvel\n    * @param {boolean} wakeUp\n    */\n    rbSetLinvel(handle, linvel, wakeUp) {\n        _assertClass(linvel, RawVector);\n        wasm.rawrigidbodyset_rbSetLinvel(this.ptr, handle, linvel.ptr, wakeUp);\n    }\n    /**\n    * Sets the angular velocity of this rigid-body.\n    * @param {number} handle\n    * @param {RawVector} angvel\n    * @param {boolean} wakeUp\n    */\n    rbSetAngvel(handle, angvel, wakeUp) {\n        _assertClass(angvel, RawVector);\n        wasm.rawrigidbodyset_rbSetAngvel(this.ptr, handle, angvel.ptr, wakeUp);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * - `z`: the world-space position of the rigid-body along the `z` axis.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    rbSetNextKinematicTranslation(handle, x, y, z) {\n        wasm.rawrigidbodyset_rbSetNextKinematicTranslation(this.ptr, handle, x, y, z);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    rbSetNextKinematicRotation(handle, x, y, z, w) {\n        wasm.rawrigidbodyset_rbSetNextKinematicRotation(this.ptr, handle, x, y, z, w);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawColliderSet} colliders\n    */\n    rbRecomputeMassPropertiesFromColliders(handle, colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders(this.ptr, handle, colliders.ptr);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {boolean} wake_up\n    */\n    rbSetAdditionalMass(handle, mass, wake_up) {\n        wasm.rawrigidbodyset_rbSetAdditionalMass(this.ptr, handle, mass, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {boolean} wake_up\n    */\n    rbSetAdditionalMassProperties(handle, mass, centerOfMass, principalAngularInertia, angularInertiaFrame, wake_up) {\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        wasm.rawrigidbodyset_rbSetAdditionalMassProperties(this.ptr, handle, mass, centerOfMass.ptr, principalAngularInertia.ptr, angularInertiaFrame.ptr, wake_up);\n    }\n    /**\n    * The linear velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbLinvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinvel(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The angular velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbAngvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngvel(this.ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockTranslations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockTranslations(this.ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} allow_x\n    * @param {boolean} allow_y\n    * @param {boolean} allow_z\n    * @param {boolean} wake_up\n    */\n    rbSetEnabledTranslations(handle, allow_x, allow_y, allow_z, wake_up) {\n        wasm.rawrigidbodyset_rbSetEnabledTranslations(this.ptr, handle, allow_x, allow_y, allow_z, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockRotations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockRotations(this.ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} allow_x\n    * @param {boolean} allow_y\n    * @param {boolean} allow_z\n    * @param {boolean} wake_up\n    */\n    rbSetEnabledRotations(handle, allow_x, allow_y, allow_z, wake_up) {\n        wasm.rawrigidbodyset_rbSetEnabledRotations(this.ptr, handle, allow_x, allow_y, allow_z, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbDominanceGroup(handle) {\n        const ret = wasm.rawrigidbodyset_rbDominanceGroup(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} group\n    */\n    rbSetDominanceGroup(handle, group) {\n        wasm.rawrigidbodyset_rbSetDominanceGroup(this.ptr, handle, group);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    rbEnableCcd(handle, enabled) {\n        wasm.rawrigidbodyset_rbEnableCcd(this.ptr, handle, enabled);\n    }\n    /**\n    * The mass of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbMass(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * Wakes this rigid-body up.\n    *\n    * A dynamic rigid-body that does not move during several consecutive frames will\n    * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n    * to avoid useless computations.\n    * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n    * the position of a dynamic body so that it is properly simulated afterwards.\n    * @param {number} handle\n    */\n    rbWakeUp(handle) {\n        wasm.rawrigidbodyset_rbWakeUp(this.ptr, handle);\n    }\n    /**\n    * Is Continuous Collision Detection enabled for this rigid-body?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsCcdEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsCcdEnabled(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The number of colliders attached to this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbNumColliders(handle) {\n        const ret = wasm.rawrigidbodyset_rbNumColliders(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Retrieves the `i-th` collider attached to this rigid-body.\n    *\n    * # Parameters\n    * - `at`: The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n    *         This index is **not** the same as the unique identifier of the collider.\n    * @param {number} handle\n    * @param {number} at\n    * @returns {number}\n    */\n    rbCollider(handle, at) {\n        const ret = wasm.rawrigidbodyset_rbCollider(this.ptr, handle, at);\n        return ret;\n    }\n    /**\n    * The status of this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbBodyType(handle) {\n        const ret = wasm.rawrigidbodyset_rbBodyType(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Set a new status for this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @param {number} status\n    * @param {boolean} wake_up\n    */\n    rbSetBodyType(handle, status, wake_up) {\n        wasm.rawrigidbodyset_rbSetBodyType(this.ptr, handle, status, wake_up);\n    }\n    /**\n    * Is this rigid-body fixed?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsFixed(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsFixed(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body kinematic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsKinematic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsKinematic(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body dynamic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsDynamic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsDynamic(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The linear damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbLinearDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinearDamping(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbAngularDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngularDamping(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetLinearDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetLinearDamping(this.ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetAngularDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetAngularDamping(this.ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    rbSetEnabled(handle, enabled) {\n        wasm.rawrigidbodyset_rbSetEnabled(this.ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsEnabled(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbGravityScale(handle) {\n        const ret = wasm.rawrigidbodyset_rbGravityScale(this.ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    * @param {boolean} wakeUp\n    */\n    rbSetGravityScale(handle, factor, wakeUp) {\n        wasm.rawrigidbodyset_rbSetGravityScale(this.ptr, handle, factor, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added forces added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    rbResetForces(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetForces(this.ptr, handle, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added torques added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    rbResetTorques(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetTorques(this.ptr, handle, wakeUp);\n    }\n    /**\n    * Adds a force at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {boolean} wakeUp\n    */\n    rbAddForce(handle, force, wakeUp) {\n        _assertClass(force, RawVector);\n        wasm.rawrigidbodyset_rbAddForce(this.ptr, handle, force.ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulse(handle, impulse, wakeUp) {\n        _assertClass(impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulse(this.ptr, handle, impulse.ptr, wakeUp);\n    }\n    /**\n    * Adds a torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque`: the world-space torque to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} torque\n    * @param {boolean} wakeUp\n    */\n    rbAddTorque(handle, torque, wakeUp) {\n        _assertClass(torque, RawVector);\n        wasm.rawrigidbodyset_rbAddTorque(this.ptr, handle, torque.ptr, wakeUp);\n    }\n    /**\n    * Applies an impulsive torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque impulse`: the world-space torque impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} torque_impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyTorqueImpulse(handle, torque_impulse, wakeUp) {\n        _assertClass(torque_impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyTorqueImpulse(this.ptr, handle, torque_impulse.ptr, wakeUp);\n    }\n    /**\n    * Adds a force at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbAddForceAtPoint(handle, force, point, wakeUp) {\n        _assertClass(force, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbAddForceAtPoint(this.ptr, handle, force.ptr, point.ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulseAtPoint(handle, impulse, point, wakeUp) {\n        _assertClass(impulse, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulseAtPoint(this.ptr, handle, impulse.ptr, point.ptr, wakeUp);\n    }\n    /**\n    * An arbitrary user-defined 32-bit integer\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbUserData(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserData(this.ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Sets the user-defined 32-bit integer of this rigid-body.\n    *\n    * # Parameters\n    * - `data`: an arbitrary user-defined 32-bit integer.\n    * @param {number} handle\n    * @param {number} data\n    */\n    rbSetUserData(handle, data) {\n        wasm.rawrigidbodyset_rbSetUserData(this.ptr, handle, data);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawrigidbodyset_new();\n        return RawRigidBodySet.__wrap(ret);\n    }\n    /**\n    * @param {boolean} enabled\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} gravityScale\n    * @param {number} mass\n    * @param {boolean} massOnly\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} linvel\n    * @param {RawVector} angvel\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {boolean} translationEnabledX\n    * @param {boolean} translationEnabledY\n    * @param {boolean} translationEnabledZ\n    * @param {boolean} rotationEnabledX\n    * @param {boolean} rotationEnabledY\n    * @param {boolean} rotationEnabledZ\n    * @param {number} linearDamping\n    * @param {number} angularDamping\n    * @param {number} rb_type\n    * @param {boolean} canSleep\n    * @param {boolean} sleeping\n    * @param {boolean} ccdEnabled\n    * @param {number} dominanceGroup\n    * @returns {number}\n    */\n    createRigidBody(enabled, translation, rotation, gravityScale, mass, massOnly, centerOfMass, linvel, angvel, principalAngularInertia, angularInertiaFrame, translationEnabledX, translationEnabledY, translationEnabledZ, rotationEnabledX, rotationEnabledY, rotationEnabledZ, linearDamping, angularDamping, rb_type, canSleep, sleeping, ccdEnabled, dominanceGroup) {\n        _assertClass(translation, RawVector);\n        _assertClass(rotation, RawRotation);\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(linvel, RawVector);\n        _assertClass(angvel, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        const ret = wasm.rawrigidbodyset_createRigidBody(this.ptr, enabled, translation.ptr, rotation.ptr, gravityScale, mass, massOnly, centerOfMass.ptr, linvel.ptr, angvel.ptr, principalAngularInertia.ptr, angularInertiaFrame.ptr, translationEnabledX, translationEnabledY, translationEnabledZ, rotationEnabledX, rotationEnabledY, rotationEnabledZ, linearDamping, angularDamping, rb_type, canSleep, sleeping, ccdEnabled, dominanceGroup);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    */\n    remove(handle, islands, colliders, joints, articulations) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        wasm.rawrigidbodyset_remove(this.ptr, handle, islands.ptr, colliders.ptr, joints.ptr, articulations.ptr);\n    }\n    /**\n    * The number of rigid-bodies on this set.\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawrigidbodyset_len(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Checks if a rigid-body with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawrigidbodyset_contains(this.ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each rigid-body managed by this set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each rigid-body managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachRigidBodyHandle(f) {\n        try {\n            wasm.rawrigidbodyset_forEachRigidBodyHandle(this.ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    */\n    propagateModifiedBodyPositionsToColliders(colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_propagateModifiedBodyPositionsToColliders(this.ptr, colliders.ptr);\n    }\n}\n/**\n* A rotation quaternion.\n*/\nexport class RawRotation {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawRotation.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrotation_free(ptr);\n    }\n    /**\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    constructor(x, y, z, w) {\n        const ret = wasm.rawrotation_new(x, y, z, w);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The identity quaternion.\n    * @returns {RawRotation}\n    */\n    static identity() {\n        const ret = wasm.rawrotation_identity();\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The `x` component of this quaternion.\n    * @returns {number}\n    */\n    get x() {\n        const ret = wasm.rawintegrationparameters_dt(this.ptr);\n        return ret;\n    }\n    /**\n    * The `y` component of this quaternion.\n    * @returns {number}\n    */\n    get y() {\n        const ret = wasm.rawrotation_y(this.ptr);\n        return ret;\n    }\n    /**\n    * The `z` component of this quaternion.\n    * @returns {number}\n    */\n    get z() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * The `w` component of this quaternion.\n    * @returns {number}\n    */\n    get w() {\n        const ret = wasm.rawrotation_w(this.ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawSerializationPipeline {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawSerializationPipeline.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawserializationpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawserializationpipeline_new();\n        return RawSerializationPipeline.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @returns {Uint8Array | undefined}\n    */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulse_joints, multibody_joints) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        const ret = wasm.rawserializationpipeline_serializeAll(this.ptr, gravity.ptr, integrationParameters.ptr, islands.ptr, broadPhase.ptr, narrowPhase.ptr, bodies.ptr, colliders.ptr, impulse_joints.ptr, multibody_joints.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {RawDeserializedWorld | undefined}\n    */\n    deserializeAll(data) {\n        const ret = wasm.rawserializationpipeline_deserializeAll(this.ptr, addHeapObject(data));\n        return ret === 0 ? undefined : RawDeserializedWorld.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShape {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawShape.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshape_free(ptr);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @param {number} hz\n    * @returns {RawShape}\n    */\n    static cuboid(hx, hy, hz) {\n        const ret = wasm.rawshape_cuboid(hx, hy, hz);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @param {number} hz\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCuboid(hx, hy, hz, borderRadius) {\n        const ret = wasm.rawshape_roundCuboid(hx, hy, hz, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static ball(radius) {\n        const ret = wasm.rawshape_ball(radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} normal\n    * @returns {RawShape}\n    */\n    static halfspace(normal) {\n        _assertClass(normal, RawVector);\n        const ret = wasm.rawshape_halfspace(normal.ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static capsule(halfHeight, radius) {\n        const ret = wasm.rawshape_capsule(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static cylinder(halfHeight, radius) {\n        const ret = wasm.rawshape_cylinder(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCylinder(halfHeight, radius, borderRadius) {\n        const ret = wasm.rawshape_roundCylinder(halfHeight, radius, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static cone(halfHeight, radius) {\n        const ret = wasm.rawshape_cone(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCone(halfHeight, radius, borderRadius) {\n        const ret = wasm.rawshape_roundCone(halfHeight, radius, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n    static polyline(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_polyline(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n    static trimesh(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_trimesh(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} nrows\n    * @param {number} ncols\n    * @param {Float32Array} heights\n    * @param {RawVector} scale\n    * @returns {RawShape}\n    */\n    static heightfield(nrows, ncols, heights, scale) {\n        const ptr0 = passArrayF32ToWasm0(heights, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(scale, RawVector);\n        const ret = wasm.rawshape_heightfield(nrows, ncols, ptr0, len0, scale.ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @returns {RawShape}\n    */\n    static segment(p1, p2) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        const ret = wasm.rawshape_segment(p1.ptr, p2.ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @returns {RawShape}\n    */\n    static triangle(p1, p2, p3) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_triangle(p1.ptr, p2.ptr, p3.ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundTriangle(p1, p2, p3, borderRadius) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_roundTriangle(p1.ptr, p2.ptr, p3.ptr, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @returns {RawShape | undefined}\n    */\n    static convexHull(points) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexHull(ptr0, len0);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexHull(points, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexHull(ptr0, len0, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape | undefined}\n    */\n    static convexMesh(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexMesh(ptr0, len0, ptr1, len1);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexMesh(vertices, indices, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexMesh(ptr0, len0, ptr1, len1, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawVector} shapeVel1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {RawVector} shapeVel2\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeTOI | undefined}\n    */\n    castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, maxToi, stop_at_penetration) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shapeVel1, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        _assertClass(shapeVel2, RawVector);\n        const ret = wasm.rawshape_castShape(this.ptr, shapePos1.ptr, shapeRot1.ptr, shapeVel1.ptr, shape2.ptr, shapePos2.ptr, shapeRot2.ptr, shapeVel2.ptr, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeTOI.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n    intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_intersectsShape(this.ptr, shapePos1.ptr, shapeRot1.ptr, shape2.ptr, shapePos2.ptr, shapeRot2.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_contactShape(this.ptr, shapePos1.ptr, shapeRot1.ptr, shape2.ptr, shapePos2.ptr, shapeRot2.ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n    containsPoint(shapePos, shapeRot, point) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_containsPoint(this.ptr, shapePos.ptr, shapeRot.ptr, point.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n    projectPoint(shapePos, shapeRot, point, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_projectPoint(this.ptr, shapePos.ptr, shapeRot.ptr, point.ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n    intersectsRay(shapePos, shapeRot, rayOrig, rayDir, maxToi) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_intersectsRay(this.ptr, shapePos.ptr, shapeRot.ptr, rayOrig.ptr, rayDir.ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n    castRay(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRay(this.ptr, shapePos.ptr, shapeRot.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n    castRayAndGetNormal(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRayAndGetNormal(this.ptr, shapePos.ptr, shapeRot.ptr, rayOrig.ptr, rayDir.ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeColliderTOI {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawShapeColliderTOI.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecollidertoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcharactercollision_handle(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        const ret = wasm.rawshapecollidertoi_witness2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawcharactercollision_worldNormal1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawshapecollidertoi_normal2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeContact {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawShapeContact.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecontact_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    distance() {\n        const ret = wasm.rawshapecontact_distance(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point1() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point2() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawshapecollidertoi_witness2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawcharactercollision_worldNormal1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeTOI {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawShapeTOI.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapetoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawintegrationparameters_dt(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        const ret = wasm.rawshapetoi_witness1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        const ret = wasm.rawcontactforceevent_total_force(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawshapetoi_normal1(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawshapetoi_normal2(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n* A vector.\n*/\nexport class RawVector {\n\n    static __wrap(ptr) {\n        const obj = Object.create(RawVector.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawvector_free(ptr);\n    }\n    /**\n    * Creates a new vector filled with zeros.\n    * @returns {RawVector}\n    */\n    static zero() {\n        const ret = wasm.rawvector_zero();\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Creates a new 3D vector from its two components.\n    *\n    * # Parameters\n    * - `x`: the `x` component of this 3D vector.\n    * - `y`: the `y` component of this 3D vector.\n    * - `z`: the `z` component of this 3D vector.\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    constructor(x, y, z) {\n        const ret = wasm.rawvector_new(x, y, z);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The `x` component of this vector.\n    * @returns {number}\n    */\n    get x() {\n        const ret = wasm.rawintegrationparameters_dt(this.ptr);\n        return ret;\n    }\n    /**\n    * Sets the `x` component of this vector.\n    * @param {number} x\n    */\n    set x(x) {\n        wasm.rawintegrationparameters_set_dt(this.ptr, x);\n    }\n    /**\n    * The `y` component of this vector.\n    * @returns {number}\n    */\n    get y() {\n        const ret = wasm.rawrotation_y(this.ptr);\n        return ret;\n    }\n    /**\n    * Sets the `y` component of this vector.\n    * @param {number} y\n    */\n    set y(y) {\n        wasm.rawvector_set_y(this.ptr, y);\n    }\n    /**\n    * The `z` component of this vector.\n    * @returns {number}\n    */\n    get z() {\n        const ret = wasm.rawcharactercollision_toi(this.ptr);\n        return ret;\n    }\n    /**\n    * Sets the `z` component of this vector.\n    * @param {number} z\n    */\n    set z(z) {\n        wasm.rawintegrationparameters_set_erp(this.ptr, z);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{x, y, z}`.\n    *\n    * This will effectively return a copy of `this`. This method exist for completeness with the\n    * other swizzling functions.\n    * @returns {RawVector}\n    */\n    xyz() {\n        const ret = wasm.rawvector_xyz(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{y, x, z}`.\n    * @returns {RawVector}\n    */\n    yxz() {\n        const ret = wasm.rawvector_yxz(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{z, x, y}`.\n    * @returns {RawVector}\n    */\n    zxy() {\n        const ret = wasm.rawvector_zxy(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{x, z, y}`.\n    * @returns {RawVector}\n    */\n    xzy() {\n        const ret = wasm.rawvector_xzy(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{y, z, x}`.\n    * @returns {RawVector}\n    */\n    yzx() {\n        const ret = wasm.rawvector_yzx(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{z, y, x}`.\n    * @returns {RawVector}\n    */\n    zyx() {\n        const ret = wasm.rawvector_zyx(this.ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nasync function load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction getImports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n        const ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_number_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'number' ? obj : undefined;\n        getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n        getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n    };\n    imports.wbg.__wbindgen_boolean_get = function(arg0) {\n        const v = getObject(arg0);\n        const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_function = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbg_rawraycolliderintersection_new = function(arg0) {\n        const ret = RawRayColliderIntersection.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_rawcontactforceevent_new = function(arg0) {\n        const ret = RawContactForceEvent.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_call_168da88779e35f61 = function() { return handleError(function (arg0, arg1, arg2) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_3999bee59e9f7719 = function() { return handleError(function (arg0, arg1, arg2, arg3) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_e1f72c051cdab859 = function() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3), getObject(arg4));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_bind_10dfe70e95d2a480 = function(arg0, arg1, arg2, arg3) {\n        const ret = getObject(arg0).bind(getObject(arg1), getObject(arg2), getObject(arg3));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_buffer_3f3d764d4747d564 = function(arg0) {\n        const ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_d9aa266703cb98be = function(arg0, arg1, arg2) {\n        const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_8c3f0052272a457a = function(arg0) {\n        const ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_83db9690f9353e79 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_length_9e1ae1900cb0fbd5 = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_be22e5fcf4f69ab4 = function(arg0, arg1, arg2) {\n        const ret = new Float32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_0e0314cf6675c1b9 = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_length_9a2deed95d22668d = function(arg0) {\n        const ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_newwithlength_a7168e4a1e8f5e12 = function(arg0) {\n        const ret = new Float32Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        const ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n\n    return imports;\n}\n\nfunction initMemory(imports, maybe_memory) {\n\n}\n\nfunction finalizeInit(instance, module) {\n    wasm = instance.exports;\n    init.__wbindgen_wasm_module = module;\n    cachedFloat32Memory0 = new Float32Array();\n    cachedFloat64Memory0 = new Float64Array();\n    cachedInt32Memory0 = new Int32Array();\n    cachedUint32Memory0 = new Uint32Array();\n    cachedUint8Memory0 = new Uint8Array();\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    const imports = getImports();\n\n    initMemory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return finalizeInit(instance, module);\n}\n\nasync function init(input) {\n    if (typeof input === 'undefined') {\n        input = new URL('rapier_wasm3d_bg.wasm', \"<deleted>\");\n    }\n    const imports = getImports();\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    initMemory(imports);\n\n    const { instance, module } = await load(await input, imports);\n\n    return finalizeInit(instance, module);\n}\n\nexport { initSync }\nexport default init;\n","import {RawVector, RawRotation} from \"./raw\";\n\n\n// #if DIM3\nexport interface Vector {\n    x: number;\n    y: number;\n    z: number;\n}\n\n/**\n * A 3D vector.\n */\nexport class Vector3 implements Vector {\n    x: number;\n    y: number;\n    z: number;\n\n    constructor(x: number, y: number, z: number) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n}\n\nexport class VectorOps {\n    public static new(x: number, y: number, z: number): Vector {\n        return new Vector3(x, y, z);\n    }\n\n    public static intoRaw(v: Vector): RawVector {\n        return new RawVector(v.x, v.y, v.z);\n    }\n\n    public static zeros(): Vector {\n        return VectorOps.new(0.0, 0.0, 0.0);\n    }\n\n    // FIXME: type ram: RawVector?\n    public static fromRaw(raw: RawVector): Vector {\n        if (!raw) return null;\n\n        let res = VectorOps.new(raw.x, raw.y, raw.z);\n        raw.free();\n        return res;\n    }\n\n    public static copy(out: Vector, input: Vector) {\n        out.x = input.x;\n        out.y = input.y;\n        out.z = input.z;\n    }\n}\n\nexport interface Rotation {\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n}\n\n/**\n * A quaternion.\n */\nexport class Quaternion implements Rotation {\n    x: number;\n    y: number;\n    z: number;\n    w: number;\n\n    constructor(x: number, y: number, z: number, w: number) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n}\n\nexport class RotationOps {\n    public static identity(): Rotation {\n        return new Quaternion(0.0, 0.0, 0.0, 1.0);\n    }\n\n    public static fromRaw(raw: RawRotation): Rotation {\n        if (!raw) return null;\n\n        let res = new Quaternion(raw.x, raw.y, raw.z, raw.w);\n        raw.free();\n        return res;\n    }\n\n    public static intoRaw(rot: Rotation): RawRotation {\n        return new RawRotation(rot.x, rot.y, rot.z, rot.w);\n    }\n\n    public static copy(out: Rotation, input: Rotation) {\n        out.x = input.x;\n        out.y = input.y;\n        out.z = input.z;\n        out.w = input.w;\n    }\n}\n\n// #endif\n","import {RawRigidBodySet} from \"../raw\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\nimport {Collider, ColliderHandle, ColliderSet} from \"../geometry\";\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type RigidBodyHandle = number;\n\n/**\n * The simulation status of a rigid-body.\n */\n// TODO: rename this to RigidBodyType\nexport enum RigidBodyType {\n    /**\n     * A `RigidBodyType::Dynamic` body can be affected by all external forces.\n     */\n    Dynamic = 0,\n    /**\n     * A `RigidBodyType::Fixed` body cannot be affected by external forces.\n     */\n    Fixed,\n    /**\n     * A `RigidBodyType::KinematicPositionBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the position level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    KinematicPositionBased,\n    /**\n     * A `RigidBodyType::KinematicVelocityBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the velocity level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    KinematicVelocityBased,\n}\n\n/**\n * A rigid-body.\n */\nexport class RigidBody {\n    private rawSet: RawRigidBodySet; // The RigidBody won't need to free this.\n    private colliderSet: ColliderSet;\n    readonly handle: RigidBodyHandle;\n\n    /**\n     * An arbitrary user-defined object associated with this rigid-body.\n     */\n    public userData?: unknown;\n\n    constructor(\n        rawSet: RawRigidBodySet,\n        colliderSet: ColliderSet,\n        handle: RigidBodyHandle,\n    ) {\n        this.rawSet = rawSet;\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n    }\n\n    /** @internal */\n    public finalizeDeserialization(colliderSet: ColliderSet) {\n        this.colliderSet = colliderSet;\n    }\n\n    /**\n     * Checks if this rigid-body is still valid (i.e. that it has\n     * not been deleted from the rigid-body set yet.\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer translate due to forces and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public lockTranslations(locked: boolean, wakeUp: boolean) {\n        return this.rawSet.rbLockTranslations(this.handle, locked, wakeUp);\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer rotate due to torques and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public lockRotations(locked: boolean, wakeUp: boolean) {\n        return this.rawSet.rbLockRotations(this.handle, locked, wakeUp);\n    }\n\n    // #if DIM3\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer translate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public setEnabledTranslations(\n        enableX: boolean,\n        enableY: boolean,\n        enableZ: boolean,\n        wakeUp: boolean,\n    ) {\n        return this.rawSet.rbSetEnabledTranslations(\n            this.handle,\n            enableX,\n            enableY,\n            enableZ,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer translate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     * @deprecated use `this.setEnabledTranslations` with the same arguments instead.\n     */\n    public restrictTranslations(\n        enableX: boolean,\n        enableY: boolean,\n        enableZ: boolean,\n        wakeUp: boolean,\n    ) {\n        this.setEnabledTranslations(enableX, enableY, enableZ, wakeUp);\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    public setEnabledRotations(\n        enableX: boolean,\n        enableY: boolean,\n        enableZ: boolean,\n        wakeUp: boolean,\n    ) {\n        return this.rawSet.rbSetEnabledRotations(\n            this.handle,\n            enableX,\n            enableY,\n            enableZ,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     * @deprecated use `this.setEnabledRotations` with the same arguments instead.\n     */\n    public restrictRotations(\n        enableX: boolean,\n        enableY: boolean,\n        enableZ: boolean,\n        wakeUp: boolean,\n    ) {\n        this.setEnabledRotations(enableX, enableY, enableZ, wakeUp);\n    }\n    // #endif\n\n    /**\n     * The dominance group, in [-127, +127] this rigid-body is part of.\n     */\n    public dominanceGroup(): number {\n        return this.rawSet.rbDominanceGroup(this.handle);\n    }\n\n    /**\n     * Sets the dominance group of this rigid-body.\n     *\n     * @param group - The dominance group of this rigid-body. Must be a signed integer in the range [-127, +127].\n     */\n    public setDominanceGroup(group: number) {\n        this.rawSet.rbSetDominanceGroup(this.handle, group);\n    }\n\n    /**\n     * Enable or disable CCD (Continuous Collision Detection) for this rigid-body.\n     *\n     * @param enabled - If `true`, CCD will be enabled for this rigid-body.\n     */\n    public enableCcd(enabled: boolean) {\n        this.rawSet.rbEnableCcd(this.handle, enabled);\n    }\n\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    public translation(): Vector {\n        let res = this.rawSet.rbTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    public rotation(): Rotation {\n        let res = this.rawSet.rbRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space next translation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    public nextTranslation(): Vector {\n        let res = this.rawSet.rbNextTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n\n    /**\n     * The world-space next orientation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    public nextRotation(): Rotation {\n        let res = this.rawSet.rbNextRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n\n    /**\n     * Sets the translation of this rigid-body.\n     *\n     * @param tra - The world-space position of the rigid-body.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     *                 wasn't moving before modifying its position.\n     */\n    public setTranslation(tra: Vector, wakeUp: boolean) {\n        // #if DIM3\n        this.rawSet.rbSetTranslation(this.handle, tra.x, tra.y, tra.z, wakeUp);\n        // #endif\n    }\n\n    /**\n     * Sets the linear velocity fo this rigid-body.\n     *\n     * @param vel - The linear velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setLinvel(vel: Vector, wakeUp: boolean) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetLinvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n\n    /**\n     * The scale factor applied to the gravity affecting\n     * this rigid-body.\n     */\n    public gravityScale(): number {\n        return this.rawSet.rbGravityScale(this.handle);\n    }\n\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * this rigid-body.\n     *\n     * @param factor - The scale factor to set. A value of 0.0 means\n     *   that this rigid-body will on longer be affected by gravity.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setGravityScale(factor: number, wakeUp: boolean) {\n        this.rawSet.rbSetGravityScale(this.handle, factor, wakeUp);\n    }\n\n    // #if DIM3\n    /**\n     * Sets the rotation quaternion of this rigid-body.\n     *\n     * This does nothing if a zero quaternion is provided.\n     *\n     * @param rotation - The rotation to set.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     */\n    public setRotation(rot: Rotation, wakeUp: boolean) {\n        this.rawSet.rbSetRotation(\n            this.handle,\n            rot.x,\n            rot.y,\n            rot.z,\n            rot.w,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Sets the angular velocity fo this rigid-body.\n     *\n     * @param vel - The angular velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    public setAngvel(vel: Vector, wakeUp: boolean) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetAngvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n\n    // #endif\n\n\n    /**\n     * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param t - The kinematic translation to set.\n     */\n    public setNextKinematicTranslation(t: Vector) {\n        // #if DIM3\n        this.rawSet.rbSetNextKinematicTranslation(this.handle, t.x, t.y, t.z);\n        // #endif\n    }\n\n    // #if DIM3\n    /**\n     * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param rot - The kinematic rotation to set.\n     */\n    public setNextKinematicRotation(rot: Rotation) {\n        this.rawSet.rbSetNextKinematicRotation(\n            this.handle,\n            rot.x,\n            rot.y,\n            rot.z,\n            rot.w,\n        );\n    }\n\n    // #endif\n\n\n    /**\n     * The linear velocity of this rigid-body.\n     */\n    public linvel(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbLinvel(this.handle));\n    }\n\n    // #if DIM3\n    /**\n     * The angular velocity of this rigid-body.\n     */\n    public angvel(): Vector {\n        return VectorOps.fromRaw(this.rawSet.rbAngvel(this.handle));\n    }\n\n    // #endif\n\n\n    /**\n     * The mass of this rigid-body.\n     */\n    public mass(): number {\n        return this.rawSet.rbMass(this.handle);\n    }\n\n    /**\n     * Put this rigid body to sleep.\n     *\n     * A sleeping body no longer moves and is no longer simulated by the physics engine unless\n     * it is waken up. It can be woken manually with `this.wakeUp()` or automatically due to\n     * external forces like contacts.\n     */\n    public sleep() {\n        this.rawSet.rbSleep(this.handle);\n    }\n\n    /**\n     * Wakes this rigid-body up.\n     *\n     * A dynamic rigid-body that does not move during several consecutive frames will\n     * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n     * to avoid useless computations.\n     * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n     * the position of a dynamic body so that it is properly simulated afterwards.\n     */\n    public wakeUp() {\n        this.rawSet.rbWakeUp(this.handle);\n    }\n\n    /**\n     * Is CCD enabled for this rigid-body?\n     */\n    public isCcdEnabled(): boolean {\n        return this.rawSet.rbIsCcdEnabled(this.handle);\n    }\n\n    /**\n     * The number of colliders attached to this rigid-body.\n     */\n    public numColliders(): number {\n        return this.rawSet.rbNumColliders(this.handle);\n    }\n\n    /**\n     * Retrieves the `i-th` collider attached to this rigid-body.\n     *\n     * @param i - The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n     *         This index is **not** the same as the unique identifier of the collider.\n     */\n    public collider(i: number): Collider {\n        return this.colliderSet.get(this.rawSet.rbCollider(this.handle, i));\n    }\n\n    /**\n     * Sets whether this rigid-body is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this rigid-body and all its attached colliders.\n     */\n    public setEnabled(enabled: boolean) {\n        this.rawSet.rbSetEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Is this rigid-body enabled?\n     */\n    public isEnabled(): boolean {\n        return this.rawSet.rbIsEnabled(this.handle);\n    }\n\n    /**\n     * The status of this rigid-body: static, dynamic, or kinematic.\n     */\n    public bodyType(): RigidBodyType {\n        return this.rawSet.rbBodyType(this.handle);\n    }\n\n    /**\n     * Set a new status for this rigid-body: static, dynamic, or kinematic.\n     */\n    public setBodyType(type: RigidBodyType, wakeUp: boolean) {\n        return this.rawSet.rbSetBodyType(this.handle, type, wakeUp);\n    }\n\n    /**\n     * Is this rigid-body sleeping?\n     */\n    public isSleeping(): boolean {\n        return this.rawSet.rbIsSleeping(this.handle);\n    }\n\n    /**\n     * Is the velocity of this rigid-body not zero?\n     */\n    public isMoving(): boolean {\n        return this.rawSet.rbIsMoving(this.handle);\n    }\n\n    /**\n     * Is this rigid-body static?\n     */\n    public isFixed(): boolean {\n        return this.rawSet.rbIsFixed(this.handle);\n    }\n\n    /**\n     * Is this rigid-body kinematic?\n     */\n    public isKinematic(): boolean {\n        return this.rawSet.rbIsKinematic(this.handle);\n    }\n\n    /**\n     * Is this rigid-body dynamic?\n     */\n    public isDynamic(): boolean {\n        return this.rawSet.rbIsDynamic(this.handle);\n    }\n\n    /**\n     * The linear damping coefficient of this rigid-body.\n     */\n    public linearDamping(): number {\n        return this.rawSet.rbLinearDamping(this.handle);\n    }\n\n    /**\n     * The angular damping coefficient of this rigid-body.\n     */\n    public angularDamping(): number {\n        return this.rawSet.rbAngularDamping(this.handle);\n    }\n\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    public setLinearDamping(factor: number) {\n        this.rawSet.rbSetLinearDamping(this.handle, factor);\n    }\n\n    /**\n     * Recompute the mass-properties of this rigid-bodies based on its currently attached colliders.\n     */\n    public recomputeMassPropertiesFromColliders() {\n        this.rawSet.rbRecomputeMassPropertiesFromColliders(\n            this.handle,\n            this.colliderSet.raw,\n        );\n    }\n\n    /**\n     * Sets the rigid-body's additional mass.\n     *\n     * The total angular inertia of the rigid-body will be scaled automatically based on this additional mass. If this\n     * scaling effect isnt desired, use Self::additional_mass_properties instead of this method.\n     *\n     * This is only the \"additional\" mass because the total mass of the rigid-body is equal to the sum of this\n     * additional mass and the mass computed from the colliders (with non-zero densities) attached to this rigid-body.\n     *\n     * That total mass (which includes the attached colliders contributions) will be updated at the name physics step,\n     * or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous additional mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc::setAdditionalMass`, or\n     * `RigidBodyDesc.setAdditionalMassfProperties` for this rigid-body.\n     *\n     * @param mass - The additional mass to set.\n     * @param wakeUp - If `true` then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    public setAdditionalMass(mass: number, wakeUp: boolean) {\n        this.rawSet.rbSetAdditionalMass(this.handle, mass, wakeUp);\n    }\n\n    // #if DIM3\n    /**\n     * Sets the rigid-body's additional mass-properties.\n     *\n     * This is only the \"additional\" mass-properties because the total mass-properties of the rigid-body is equal to the\n     * sum of this additional mass-properties and the mass computed from the colliders (with non-zero densities) attached\n     * to this rigid-body.\n     *\n     * That total mass-properties (which include the attached colliders contributions) will be updated at the name\n     * physics step, or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc.setAdditionalMass`, or `RigidBodyDesc.setAdditionalMassProperties`\n     * for this rigid-body.\n     *\n     * If `wake_up` is true then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    public setAdditionalMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: Vector,\n        angularInertiaLocalFrame: Rotation,\n        wakeUp: boolean,\n    ) {\n        let rawCom = VectorOps.intoRaw(centerOfMass);\n        let rawPrincipalInertia = VectorOps.intoRaw(principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(angularInertiaLocalFrame);\n\n        this.rawSet.rbSetAdditionalMassProperties(\n            this.handle,\n            mass,\n            rawCom,\n            rawPrincipalInertia,\n            rawInertiaFrame,\n            wakeUp,\n        );\n\n        rawCom.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n    }\n    // #endif\n\n\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    public setAngularDamping(factor: number) {\n        this.rawSet.rbSetAngularDamping(this.handle, factor);\n    }\n\n    /**\n     * Resets to zero the user forces (but not torques) applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public resetForces(wakeUp: boolean) {\n        this.rawSet.rbResetForces(this.handle, wakeUp);\n    }\n\n    /**\n     * Resets to zero the user torques applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public resetTorques(wakeUp: boolean) {\n        this.rawSet.rbResetTorques(this.handle, wakeUp);\n    }\n\n    /**\n     * Adds a force at the center-of-mass of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public addForce(force: Vector, wakeUp: boolean) {\n        const rawForce = VectorOps.intoRaw(force);\n        this.rawSet.rbAddForce(this.handle, rawForce, wakeUp);\n        rawForce.free();\n    }\n\n    /**\n     * Applies an impulse at the center-of-mass of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyImpulse(impulse: Vector, wakeUp: boolean) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        this.rawSet.rbApplyImpulse(this.handle, rawImpulse, wakeUp);\n        rawImpulse.free();\n    }\n\n\n    // #if DIM3\n    /**\n     * Adds a torque at the center-of-mass of this rigid-body.\n     *\n     * @param torque - the world-space torque to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public addTorque(torque: Vector, wakeUp: boolean) {\n        const rawTorque = VectorOps.intoRaw(torque);\n        this.rawSet.rbAddTorque(this.handle, rawTorque, wakeUp);\n        rawTorque.free();\n    }\n\n    // #endif\n\n\n    // #if DIM3\n    /**\n     * Applies an impulsive torque at the center-of-mass of this rigid-body.\n     *\n     * @param torqueImpulse - the world-space torque impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyTorqueImpulse(torqueImpulse: Vector, wakeUp: boolean) {\n        const rawTorqueImpulse = VectorOps.intoRaw(torqueImpulse);\n        this.rawSet.rbApplyTorqueImpulse(this.handle, rawTorqueImpulse, wakeUp);\n        rawTorqueImpulse.free();\n    }\n\n    // #endif\n\n    /**\n     * Adds a force at the given world-space point of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public addForceAtPoint(force: Vector, point: Vector, wakeUp: boolean) {\n        const rawForce = VectorOps.intoRaw(force);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbAddForceAtPoint(this.handle, rawForce, rawPoint, wakeUp);\n        rawForce.free();\n        rawPoint.free();\n    }\n\n    /**\n     * Applies an impulse at the given world-space point of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    public applyImpulseAtPoint(\n        impulse: Vector,\n        point: Vector,\n        wakeUp: boolean,\n    ) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbApplyImpulseAtPoint(\n            this.handle,\n            rawImpulse,\n            rawPoint,\n            wakeUp,\n        );\n        rawImpulse.free();\n        rawPoint.free();\n    }\n}\n\nexport class RigidBodyDesc {\n    enabled: boolean;\n    translation: Vector;\n    rotation: Rotation;\n    gravityScale: number;\n    mass: number;\n    massOnly: boolean;\n    centerOfMass: Vector;\n    translationsEnabledX: boolean;\n    translationsEnabledY: boolean;\n    linvel: Vector;\n    // #if DIM3\n    angvel: Vector;\n    principalAngularInertia: Vector;\n    angularInertiaLocalFrame: Rotation;\n    translationsEnabledZ: boolean;\n    rotationsEnabledX: boolean;\n    rotationsEnabledY: boolean;\n    rotationsEnabledZ: boolean;\n    // #endif\n    linearDamping: number;\n    angularDamping: number;\n    status: RigidBodyType;\n    canSleep: boolean;\n    sleeping: boolean;\n    ccdEnabled: boolean;\n    dominanceGroup: number;\n    userData?: unknown;\n\n    constructor(status: RigidBodyType) {\n        this.enabled = true;\n        this.status = status;\n        this.translation = VectorOps.zeros();\n        this.rotation = RotationOps.identity();\n        this.gravityScale = 1.0;\n        this.linvel = VectorOps.zeros();\n        this.mass = 0.0;\n        this.massOnly = false;\n        this.centerOfMass = VectorOps.zeros();\n        this.translationsEnabledX = true;\n        this.translationsEnabledY = true;\n        // #if DIM3\n        this.angvel = VectorOps.zeros();\n        this.principalAngularInertia = VectorOps.zeros();\n        this.angularInertiaLocalFrame = RotationOps.identity();\n        this.translationsEnabledZ = true;\n        this.rotationsEnabledX = true;\n        this.rotationsEnabledY = true;\n        this.rotationsEnabledZ = true;\n        // #endif\n        this.linearDamping = 0.0;\n        this.angularDamping = 0.0;\n        this.canSleep = true;\n        this.sleeping = false;\n        this.ccdEnabled = false;\n        this.dominanceGroup = 0;\n    }\n\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     */\n    public static dynamic(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     */\n    public static kinematicPositionBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     */\n    public static kinematicVelocityBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     */\n    public static fixed(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.dynamic()`.\n     */\n    public static newDynamic(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicPositionBased()`.\n     */\n    public static newKinematicPositionBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicVelocityBased()`.\n     */\n    public static newKinematicVelocityBased(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     *\n     * @deprecated The method has been renamed to `.fixed()`.\n     */\n    public static newStatic(): RigidBodyDesc {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n\n    public setDominanceGroup(group: number): RigidBodyDesc {\n        this.dominanceGroup = group;\n        return this;\n    }\n\n    /**\n     * Sets whether the created rigid-body will be enabled or disabled.\n     * @param enabled  If set to `false` the rigid-body will be disabled at creation.\n     */\n    public setEnabled(enabled: boolean): RigidBodyDesc {\n        this.enabled = enabled;\n        return this;\n    }\n\n\n    // #if DIM3\n    /**\n     * Sets the initial translation of the rigid-body to create.\n     *\n     * @param tra - The translation to set.\n     */\n    public setTranslation(x: number, y: number, z: number): RigidBodyDesc {\n        if (\n            typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\"\n        )\n            throw TypeError(\"The translation components must be numbers.\");\n\n        this.translation = {x: x, y: y, z: z};\n        return this;\n    }\n\n    // #endif\n\n    /**\n     * Sets the initial rotation of the rigid-body to create.\n     *\n     * @param rot - The rotation to set.\n     */\n    public setRotation(rot: Rotation): RigidBodyDesc {\n        // #if DIM3\n        RotationOps.copy(this.rotation, rot);\n        // #endif\n        return this;\n    }\n\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * the rigid-body being built.\n     *\n     * @param scale - The scale factor. Set this to `0.0` if the rigid-body\n     *   needs to ignore gravity.\n     */\n    public setGravityScale(scale: number): RigidBodyDesc {\n        this.gravityScale = scale;\n        return this;\n    }\n\n    /**\n     * Sets the initial mass of the rigid-body being built, before adding colliders' contributions.\n     *\n     * @param mass  The initial mass of the rigid-body to create.\n     */\n    public setAdditionalMass(mass: number): RigidBodyDesc {\n        this.mass = mass;\n        this.massOnly = true;\n        return this;\n    }\n\n\n    // #if DIM3\n    /**\n     * Sets the initial linear velocity of the rigid-body to create.\n     *\n     * @param x - The linear velocity to set along the `x` axis.\n     * @param y - The linear velocity to set along the `y` axis.\n     * @param z - The linear velocity to set along the `z` axis.\n     */\n    public setLinvel(x: number, y: number, z: number): RigidBodyDesc {\n        if (\n            typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\"\n        )\n            throw TypeError(\"The linvel components must be numbers.\");\n\n        this.linvel = {x: x, y: y, z: z};\n        return this;\n    }\n\n    /**\n     * Sets the initial angular velocity of the rigid-body to create.\n     *\n     * @param vel - The angular velocity to set.\n     */\n    public setAngvel(vel: Vector): RigidBodyDesc {\n        VectorOps.copy(this.angvel, vel);\n        return this;\n    }\n\n    /**\n     * Sets the mass properties of the rigid-body being built.\n     *\n     * Note that the final mass properties of the rigid-bodies depends\n     * on the initial mass-properties of the rigid-body (set by this method)\n     * to which is added the contributions of all the colliders with non-zero density\n     * attached to this rigid-body.\n     *\n     * Therefore, if you want your provided mass properties to be the final\n     * mass properties of your rigid-body, don't attach colliders to it, or\n     * only attach colliders with densities equal to zero.\n     *\n     * @param mass  The initial mass of the rigid-body to create.\n     * @param centerOfMass  The initial center-of-mass of the rigid-body to create.\n     * @param principalAngularInertia  The initial principal angular inertia of the rigid-body to create.\n     *                                  These are the eigenvalues of the angular inertia matrix.\n     * @param angularInertiaLocalFrame  The initial local angular inertia frame of the rigid-body to create.\n     *                                   These are the eigenvectors of the angular inertia matrix.\n     */\n    public setAdditionalMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: Vector,\n        angularInertiaLocalFrame: Rotation,\n    ): RigidBodyDesc {\n        this.mass = mass;\n        VectorOps.copy(this.centerOfMass, centerOfMass);\n        VectorOps.copy(this.principalAngularInertia, principalAngularInertia);\n        RotationOps.copy(\n            this.angularInertiaLocalFrame,\n            angularInertiaLocalFrame,\n        );\n        this.massOnly = false;\n        return this;\n    }\n\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @param translationsEnabledZ - Are translations along the Z axis enabled?\n     */\n    public enabledTranslations(\n        translationsEnabledX: boolean,\n        translationsEnabledY: boolean,\n        translationsEnabledZ: boolean,\n    ): RigidBodyDesc {\n        this.translationsEnabledX = translationsEnabledX;\n        this.translationsEnabledY = translationsEnabledY;\n        this.translationsEnabledZ = translationsEnabledZ;\n        return this;\n    }\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @param translationsEnabledZ - Are translations along the Z axis enabled?\n     * @deprecated use `this.enabledTranslations` with the same arguments instead.\n     */\n    public restrictTranslations(\n        translationsEnabledX: boolean,\n        translationsEnabledY: boolean,\n        translationsEnabledZ: boolean,\n    ): RigidBodyDesc {\n        return this.enabledTranslations(\n            translationsEnabledX,\n            translationsEnabledY,\n            translationsEnabledZ,\n        );\n    }\n\n    /**\n     * Locks all translations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    public lockTranslations(): RigidBodyDesc {\n        return this.enabledTranslations(false, false, false);\n    }\n\n    /**\n     * Allow rotation of this rigid-body only along specific axes.\n     * @param rotationsEnabledX - Are rotations along the X axis enabled?\n     * @param rotationsEnabledY - Are rotations along the y axis enabled?\n     * @param rotationsEnabledZ - Are rotations along the Z axis enabled?\n     */\n    public enabledRotations(\n        rotationsEnabledX: boolean,\n        rotationsEnabledY: boolean,\n        rotationsEnabledZ: boolean,\n    ): RigidBodyDesc {\n        this.rotationsEnabledX = rotationsEnabledX;\n        this.rotationsEnabledY = rotationsEnabledY;\n        this.rotationsEnabledZ = rotationsEnabledZ;\n        return this;\n    }\n\n    /**\n     * Allow rotation of this rigid-body only along specific axes.\n     * @param rotationsEnabledX - Are rotations along the X axis enabled?\n     * @param rotationsEnabledY - Are rotations along the y axis enabled?\n     * @param rotationsEnabledZ - Are rotations along the Z axis enabled?\n     * @deprecated use `this.enabledRotations` with the same arguments instead.\n     */\n    public restrictRotations(\n        rotationsEnabledX: boolean,\n        rotationsEnabledY: boolean,\n        rotationsEnabledZ: boolean,\n    ): RigidBodyDesc {\n        return this.enabledRotations(\n            rotationsEnabledX,\n            rotationsEnabledY,\n            rotationsEnabledZ,\n        );\n    }\n\n    /**\n     * Locks all rotations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    public lockRotations(): RigidBodyDesc {\n        return this.restrictRotations(false, false, false);\n    }\n\n    // #endif\n\n    /**\n     * Sets the linear damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the translational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the translational slowdown will be.\n     */\n    public setLinearDamping(damping: number): RigidBodyDesc {\n        this.linearDamping = damping;\n        return this;\n    }\n\n    /**\n     * Sets the angular damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the rotational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the rotational slowdown will be.\n     */\n    public setAngularDamping(damping: number): RigidBodyDesc {\n        this.angularDamping = damping;\n        return this;\n    }\n\n    /**\n     * Sets whether or not the rigid-body to create can sleep.\n     *\n     * @param can - true if the rigid-body can sleep, false if it can't.\n     */\n    public setCanSleep(can: boolean): RigidBodyDesc {\n        this.canSleep = can;\n        return this;\n    }\n\n    /**\n     * Sets whether or not the rigid-body is to be created asleep.\n     *\n     * @param can - true if the rigid-body should be in sleep, default false.\n     */\n    setSleeping(sleeping: boolean): RigidBodyDesc {\n        this.sleeping = sleeping;\n        return this;\n    }\n\n    /**\n     * Sets whether Continuous Collision Detection (CCD) is enabled for this rigid-body.\n     *\n     * @param enabled - true if the rigid-body has CCD enabled.\n     */\n    public setCcdEnabled(enabled: boolean): RigidBodyDesc {\n        this.ccdEnabled = enabled;\n        return this;\n    }\n\n    /**\n     * Sets the user-defined object of this rigid-body.\n     *\n     * @param userData - The user-defined object to set.\n     */\n    public setUserData(data?: unknown): RigidBodyDesc {\n        this.userData = data;\n        return this;\n    }\n}\n","import {Rotation, Vector, VectorOps, RotationOps} from \"../math\";\nimport {\n    RawGenericJoint,\n    RawImpulseJointSet,\n    RawRigidBodySet,\n    RawJointAxis,\n} from \"../raw\";\nimport {RigidBody, RigidBodyHandle} from \"./rigid_body\";\nimport {RigidBodySet} from \"./rigid_body_set\";\n// #if DIM3\nimport {Quaternion} from \"../math\";\n// #endif\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type ImpulseJointHandle = number;\n\n/**\n * An enum grouping all possible types of joints:\n *\n * - `Revolute`: A revolute joint that removes all degrees of freedom between the affected\n *               bodies except for the rotation along one axis.\n * - `Fixed`: A fixed joint that removes all relative degrees of freedom between the affected bodies.\n * - `Prismatic`: A prismatic joint that removes all degrees of freedom between the affected\n *                bodies except for the translation along one axis.\n * - `Spherical`: (3D only) A spherical joint that removes all relative linear degrees of freedom between the affected bodies.\n */\nexport enum JointType {\n    Revolute,\n    Fixed,\n    Prismatic,\n    // #if DIM3\n    Spherical,\n    // #endif\n}\n\nexport enum MotorModel {\n    AccelerationBased,\n    ForceBased,\n}\n\nexport class ImpulseJoint {\n    protected rawSet: RawImpulseJointSet; // The ImpulseJoint won't need to free this.\n    protected bodySet: RigidBodySet; // The ImpulseJoint wont need to free this.\n    handle: ImpulseJointHandle;\n\n    constructor(\n        rawSet: RawImpulseJointSet,\n        bodySet: RigidBodySet,\n        handle: ImpulseJointHandle,\n    ) {\n        this.rawSet = rawSet;\n        this.bodySet = bodySet;\n        this.handle = handle;\n    }\n\n    public static newTyped(\n        rawSet: RawImpulseJointSet,\n        bodySet: RigidBodySet,\n        handle: ImpulseJointHandle,\n    ): ImpulseJoint {\n        switch (rawSet.jointType(handle)) {\n            case JointType.Revolute:\n                return new RevoluteImpulseJoint(rawSet, bodySet, handle);\n            case JointType.Prismatic:\n                return new PrismaticImpulseJoint(rawSet, bodySet, handle);\n            case JointType.Fixed:\n                return new FixedImpulseJoint(rawSet, bodySet, handle);\n            // #if DIM3\n            case JointType.Spherical:\n                return new SphericalImpulseJoint(rawSet, bodySet, handle);\n            // #endif\n            default:\n                return new ImpulseJoint(rawSet, bodySet, handle);\n        }\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodySet: RigidBodySet) {\n        this.bodySet = bodySet;\n    }\n\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    /**\n     * The first rigid-body this joint it attached to.\n     */\n    public body1(): RigidBody {\n        return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));\n    }\n\n    /**\n     * The second rigid-body this joint is attached to.\n     */\n    public body2(): RigidBody {\n        return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));\n    }\n\n    /**\n     * The type of this joint given as a string.\n     */\n    public type(): JointType {\n        return this.rawSet.jointType(this.handle);\n    }\n\n    // #if DIM3\n    /**\n     * The rotation quaternion that aligns this joint's first local axis to the `x` axis.\n     */\n    public frameX1(): Rotation {\n        return RotationOps.fromRaw(this.rawSet.jointFrameX1(this.handle));\n    }\n\n    // #endif\n\n    // #if DIM3\n    /**\n     * The rotation matrix that aligns this joint's second local axis to the `x` axis.\n     */\n    public frameX2(): Rotation {\n        return RotationOps.fromRaw(this.rawSet.jointFrameX2(this.handle));\n    }\n\n    // #endif\n\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    public anchor1(): Vector {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    }\n\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    public anchor2(): Vector {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    }\n\n    /**\n     * Sets the position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    public setAnchor1(newPos: Vector) {\n        const rawPoint = VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor1(this.handle, rawPoint);\n        rawPoint.free();\n    }\n\n    /**\n     * Sets the position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    public setAnchor2(newPos: Vector) {\n        const rawPoint = VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor2(this.handle, rawPoint);\n        rawPoint.free();\n    }\n\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public setContactsEnabled(enabled: boolean) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public contactsEnabled(): boolean {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\n\nexport class UnitImpulseJoint extends ImpulseJoint {\n    /**\n     * The axis left free by this joint.\n     */\n    protected rawAxis?(): RawJointAxis;\n\n    /**\n     * Are the limits enabled for this joint?\n     */\n    public limitsEnabled(): boolean {\n        return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());\n    }\n\n    /**\n     * The min limit of this joint.\n     */\n    public limitsMin(): number {\n        return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());\n    }\n\n    /**\n     * The max limit of this joint.\n     */\n    public limitsMax(): number {\n        return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());\n    }\n\n    /**\n     * Sets the limits of this joint.\n     *\n     * @param min - The minimum bound of this joints free coordinate.\n     * @param max - The maximum bound of this joints free coordinate.\n     */\n    public setLimits(min: number, max: number) {\n        this.rawSet.jointSetLimits(this.handle, this.rawAxis(), min, max);\n    }\n\n    public configureMotorModel(model: MotorModel) {\n        this.rawSet.jointConfigureMotorModel(\n            this.handle,\n            this.rawAxis(),\n            model,\n        );\n    }\n\n    public configureMotorVelocity(targetVel: number, factor: number) {\n        this.rawSet.jointConfigureMotorVelocity(\n            this.handle,\n            this.rawAxis(),\n            targetVel,\n            factor,\n        );\n    }\n\n    public configureMotorPosition(\n        targetPos: number,\n        stiffness: number,\n        damping: number,\n    ) {\n        this.rawSet.jointConfigureMotorPosition(\n            this.handle,\n            this.rawAxis(),\n            targetPos,\n            stiffness,\n            damping,\n        );\n    }\n\n    public configureMotor(\n        targetPos: number,\n        targetVel: number,\n        stiffness: number,\n        damping: number,\n    ) {\n        this.rawSet.jointConfigureMotor(\n            this.handle,\n            this.rawAxis(),\n            targetPos,\n            targetVel,\n            stiffness,\n            damping,\n        );\n    }\n}\n\nexport class FixedImpulseJoint extends ImpulseJoint {}\n\nexport class PrismaticImpulseJoint extends UnitImpulseJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.X;\n    }\n}\n\nexport class RevoluteImpulseJoint extends UnitImpulseJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.AngX;\n    }\n}\n\n// #if DIM3\nexport class SphericalImpulseJoint extends ImpulseJoint {\n    /* Unsupported by this alpha release.\n    public configureMotorModel(model: MotorModel) {\n        this.rawSet.jointConfigureMotorModel(this.handle, model);\n    }\n\n    public configureMotorVelocity(targetVel: Vector, factor: number) {\n        this.rawSet.jointConfigureBallMotorVelocity(this.handle, targetVel.x, targetVel.y, targetVel.z, factor);\n    }\n\n    public configureMotorPosition(targetPos: Quaternion, stiffness: number, damping: number) {\n        this.rawSet.jointConfigureBallMotorPosition(this.handle, targetPos.w, targetPos.x, targetPos.y, targetPos.z, stiffness, damping);\n    }\n\n    public configureMotor(targetPos: Quaternion, targetVel: Vector, stiffness: number, damping: number) {\n        this.rawSet.jointConfigureBallMotor(this.handle,\n            targetPos.w, targetPos.x, targetPos.y, targetPos.z,\n            targetVel.x, targetVel.y, targetVel.z,\n            stiffness, damping);\n    }\n     */\n}\n// #endif\n\nexport class JointData {\n    anchor1: Vector;\n    anchor2: Vector;\n    axis: Vector;\n    frame1: Rotation;\n    frame2: Rotation;\n    jointType: JointType;\n    limitsEnabled: boolean;\n    limits: Array<number>;\n\n    private constructor() {}\n\n    /**\n     * Creates a new joint descriptor that builds a Fixed joint.\n     *\n     * A fixed joint removes all the degrees of freedom between the affected bodies, ensuring their\n     * anchor and local frames coincide in world-space.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame1 - The reference orientation of the joint wrt. the first rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame2 - The reference orientation of the joint wrt. the second rigid-body.\n     */\n    public static fixed(\n        anchor1: Vector,\n        frame1: Rotation,\n        anchor2: Vector,\n        frame2: Rotation,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.frame1 = frame1;\n        res.frame2 = frame2;\n        res.jointType = JointType.Fixed;\n        return res;\n    }\n\n\n    // #if DIM3\n    /**\n     * Create a new joint descriptor that builds spherical joints.\n     *\n     * A spherical joint allows three relative rotational degrees of freedom\n     * by preventing any relative translation between the anchors of the\n     * two attached rigid-bodies.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     */\n    public static spherical(anchor1: Vector, anchor2: Vector): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.jointType = JointType.Spherical;\n        return res;\n    }\n\n    /**\n     * Creates a new joint descriptor that builds a Prismatic joint.\n     *\n     * A prismatic joint removes all the degrees of freedom between the\n     * affected bodies, except for the translation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    public static prismatic(\n        anchor1: Vector,\n        anchor2: Vector,\n        axis: Vector,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Prismatic;\n        return res;\n    }\n\n    /**\n     * Create a new joint descriptor that builds Revolute joints.\n     *\n     * A revolute joint removes all degrees of freedom between the affected\n     * bodies except for the rotation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    public static revolute(\n        anchor1: Vector,\n        anchor2: Vector,\n        axis: Vector,\n    ): JointData {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Revolute;\n        return res;\n    }\n\n    // #endif\n\n    public intoRaw(): RawGenericJoint {\n        let rawA1 = VectorOps.intoRaw(this.anchor1);\n        let rawA2 = VectorOps.intoRaw(this.anchor2);\n        let rawAx;\n        let result;\n        let limitsEnabled = false;\n        let limitsMin = 0.0;\n        let limitsMax = 0.0;\n\n        switch (this.jointType) {\n            case JointType.Fixed:\n                let rawFra1 = RotationOps.intoRaw(this.frame1);\n                let rawFra2 = RotationOps.intoRaw(this.frame2);\n                result = RawGenericJoint.fixed(rawA1, rawFra1, rawA2, rawFra2);\n                rawFra1.free();\n                rawFra2.free();\n                break;\n            case JointType.Prismatic:\n                rawAx = VectorOps.intoRaw(this.axis);\n\n                if (!!this.limitsEnabled) {\n                    limitsEnabled = true;\n                    limitsMin = this.limits[0];\n                    limitsMax = this.limits[1];\n                }\n\n\n                // #if DIM3\n                result = RawGenericJoint.prismatic(\n                    rawA1,\n                    rawA2,\n                    rawAx,\n                    limitsEnabled,\n                    limitsMin,\n                    limitsMax,\n                );\n                // #endif\n\n                rawAx.free();\n                break;\n            // #if DIM3\n            case JointType.Spherical:\n                result = RawGenericJoint.spherical(rawA1, rawA2);\n                break;\n            case JointType.Revolute:\n                rawAx = VectorOps.intoRaw(this.axis);\n                result = RawGenericJoint.revolute(rawA1, rawA2, rawAx);\n                rawAx.free();\n                break;\n            // #endif\n        }\n\n        rawA1.free();\n        rawA2.free();\n\n        return result;\n    }\n}\n","/**\n * A rule applied to combine coefficients.\n *\n * Use this when configuring the `ColliderDesc` to specify\n * how friction and restitution coefficient should be combined\n * in a contact.\n */\nexport enum CoefficientCombineRule {\n    Average = 0,\n    Min = 1,\n    Multiply = 2,\n    Max = 3,\n}\n","\n// #if DIM3\nexport enum FeatureType {\n    Vertex,\n    Edge,\n    Face,\n    Unknown,\n}\n// #endif\n","import {Vector, VectorOps, Rotation, RotationOps} from \"../math\";\nimport {RawColliderSet, RawShape} from \"../raw\";\nimport {ShapeContact} from \"./contact\";\nimport {PointProjection} from \"./point\";\nimport {Ray, RayIntersection} from \"./ray\";\nimport {ShapeTOI} from \"./toi\";\nimport {ColliderHandle} from \"./collider\";\n\nexport abstract class Shape {\n    public abstract intoRaw(): RawShape;\n\n    /**\n     * The concrete type of this shape.\n     */\n    public abstract get type(): ShapeType;\n\n    /**\n     * instant mode without cache\n     */\n    public static fromRaw(\n        rawSet: RawColliderSet,\n        handle: ColliderHandle,\n    ): Shape {\n        const rawType = rawSet.coShapeType(handle);\n\n        let extents: Vector;\n        let borderRadius: number;\n        let vs: Float32Array;\n        let indices: Uint32Array;\n        let halfHeight: number;\n        let radius: number;\n        let normal: Vector;\n\n        switch (rawType) {\n            case ShapeType.Ball:\n                return new Ball(rawSet.coRadius(handle));\n            case ShapeType.Cuboid:\n                extents = rawSet.coHalfExtents(handle);\n\n                // #if DIM3\n                return new Cuboid(extents.x, extents.y, extents.z);\n            // #endif\n\n            case ShapeType.RoundCuboid:\n                extents = rawSet.coHalfExtents(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n\n\n                // #if DIM3\n                return new RoundCuboid(\n                    extents.x,\n                    extents.y,\n                    extents.z,\n                    borderRadius,\n                );\n            // #endif\n\n            case ShapeType.Capsule:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Capsule(halfHeight, radius);\n            case ShapeType.Segment:\n                vs = rawSet.coVertices(handle);\n\n\n                // #if DIM3\n                return new Segment(\n                    VectorOps.new(vs[0], vs[1], vs[2]),\n                    VectorOps.new(vs[3], vs[4], vs[5]),\n                );\n            // #endif\n\n            case ShapeType.Polyline:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new Polyline(vs, indices);\n            case ShapeType.Triangle:\n                vs = rawSet.coVertices(handle);\n\n\n                // #if DIM3\n                return new Triangle(\n                    VectorOps.new(vs[0], vs[1], vs[2]),\n                    VectorOps.new(vs[3], vs[4], vs[5]),\n                    VectorOps.new(vs[6], vs[7], vs[8]),\n                );\n            // #endif\n\n            case ShapeType.RoundTriangle:\n                vs = rawSet.coVertices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n\n\n                // #if DIM3\n                return new RoundTriangle(\n                    VectorOps.new(vs[0], vs[1], vs[2]),\n                    VectorOps.new(vs[3], vs[4], vs[5]),\n                    VectorOps.new(vs[6], vs[7], vs[8]),\n                    borderRadius,\n                );\n            // #endif\n\n            case ShapeType.HalfSpace:\n                normal = VectorOps.fromRaw(rawSet.coHalfspaceNormal(handle));\n                return new HalfSpace(normal);\n\n            case ShapeType.TriMesh:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new TriMesh(vs, indices);\n\n            case ShapeType.HeightField:\n                const scale = rawSet.coHeightfieldScale(handle);\n                const heights = rawSet.coHeightfieldHeights(handle);\n\n\n                // #if DIM3\n                const nrows = rawSet.coHeightfieldNRows(handle);\n                const ncols = rawSet.coHeightfieldNCols(handle);\n                return new Heightfield(nrows, ncols, heights, scale);\n            // #endif\n\n\n            // #if DIM3\n            case ShapeType.ConvexPolyhedron:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new ConvexPolyhedron(vs, indices);\n            case ShapeType.RoundConvexPolyhedron:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundConvexPolyhedron(vs, indices, borderRadius);\n            case ShapeType.Cylinder:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Cylinder(halfHeight, radius);\n            case ShapeType.RoundCylinder:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundCylinder(halfHeight, radius, borderRadius);\n            case ShapeType.Cone:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Cone(halfHeight, radius);\n            case ShapeType.RoundCone:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundCone(halfHeight, radius, borderRadius);\n            // #endif\n\n            default:\n                throw new Error(\"unknown shape type: \" + rawType);\n        }\n    }\n\n    /**\n     * Computes the time of impact between two moving shapes.\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shapeVel1 - The velocity of this shape.\n     * @param shape2 - The second moving shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param shapeVel2 - The velocity of the second shape.\n     * @param maxToi - The maximum time when the impact can happen.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     * @returns If the two moving shapes collider at some point along their trajectories, this returns the\n     *  time at which the two shape collider as well as the contact information during the impact. Returns\n     *  `null`if the two shapes never collide along their paths.\n     */\n    public castShape(\n        shapePos1: Vector,\n        shapeRot1: Rotation,\n        shapeVel1: Vector,\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n        shapeVel2: Vector,\n        maxToi: number,\n        stopAtPenetration: boolean,\n    ): ShapeTOI | null {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawVel1 = VectorOps.intoRaw(shapeVel1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawVel2 = VectorOps.intoRaw(shapeVel2);\n\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeTOI.fromRaw(\n            null,\n            rawShape1.castShape(\n                rawPos1,\n                rawRot1,\n                rawVel1,\n                rawShape2,\n                rawPos2,\n                rawRot2,\n                rawVel2,\n                maxToi,\n                stopAtPenetration,\n            ),\n        );\n\n        rawPos1.free();\n        rawRot1.free();\n        rawVel1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawVel2.free();\n\n        rawShape1.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Tests if this shape intersects another shape.\n     *\n     * @param shapePos1 - The position of this shape.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2  - The second shape to test.\n     * @param shapePos2 - The position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @returns `true` if the two shapes intersect, `false` if they dont.\n     */\n    public intersectsShape(\n        shapePos1: Vector,\n        shapeRot1: Rotation,\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n    ): boolean {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n\n        let result = rawShape1.intersectsShape(\n            rawPos1,\n            rawRot1,\n            rawShape2,\n            rawPos2,\n            rawRot2,\n        );\n\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n\n        rawShape1.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Computes one pair of contact points between two shapes.\n     *\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2 - The second shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(\n        shapePos1: Vector,\n        shapeRot1: Rotation,\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n        prediction: number,\n    ): ShapeContact | null {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeContact.fromRaw(\n            rawShape1.contactShape(\n                rawPos1,\n                rawRot1,\n                rawShape2,\n                rawPos2,\n                rawRot2,\n                prediction,\n            ),\n        );\n\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n\n        rawShape1.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    containsPoint(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        point: Vector,\n    ): boolean {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n\n        let result = rawShape.containsPoint(rawPos, rawRot, rawPoint);\n\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    projectPoint(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        point: Vector,\n        solid: boolean,\n    ): PointProjection {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n\n        let result = PointProjection.fromRaw(\n            rawShape.projectPoint(rawPos, rawRot, rawPoint, solid),\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    intersectsRay(\n        ray: Ray,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        maxToi: number,\n    ): boolean {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n\n        let result = rawShape.intersectsRay(\n            rawPos,\n            rawRot,\n            rawRayOrig,\n            rawRayDir,\n            maxToi,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    castRay(\n        ray: Ray,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        maxToi: number,\n        solid: boolean,\n    ): number {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n\n        let result = rawShape.castRay(\n            rawPos,\n            rawRot,\n            rawRayOrig,\n            rawRayDir,\n            maxToi,\n            solid,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    castRayAndGetNormal(\n        ray: Ray,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        maxToi: number,\n        solid: boolean,\n    ): RayIntersection {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n\n        let result = RayIntersection.fromRaw(\n            rawShape.castRayAndGetNormal(\n                rawPos,\n                rawRot,\n                rawRayOrig,\n                rawRayDir,\n                maxToi,\n                solid,\n            ),\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n\n        return result;\n    }\n}\n\n\n// #if DIM3\n/**\n * An enumeration representing the type of a shape.\n */\nexport enum ShapeType {\n    Ball = 0,\n    Cuboid = 1,\n    Capsule = 2,\n    Segment = 3,\n    Polyline = 4,\n    Triangle = 5,\n    TriMesh = 6,\n    HeightField = 7,\n    // Compound = 8,\n    ConvexPolyhedron = 9,\n    Cylinder = 10,\n    Cone = 11,\n    RoundCuboid = 12,\n    RoundTriangle = 13,\n    RoundCylinder = 14,\n    RoundCone = 15,\n    RoundConvexPolyhedron = 16,\n    HalfSpace = 17,\n}\n\n// #endif\n\n/**\n * A shape that is a sphere in 3D and a circle in 2D.\n */\nexport class Ball extends Shape {\n    readonly type = ShapeType.Ball;\n\n    /**\n     * The balls radius.\n     */\n    radius: number;\n\n    /**\n     * Creates a new ball with the given radius.\n     * @param radius - The balls radius.\n     */\n    constructor(radius: number) {\n        super();\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.ball(this.radius);\n    }\n}\n\nexport class HalfSpace extends Shape {\n    readonly type = ShapeType.HalfSpace;\n\n    /**\n     * The outward normal of the half-space.\n     */\n    normal: Vector;\n\n    /**\n     * Creates a new halfspace delimited by an infinite plane.\n     *\n     * @param normal - The outward normal of the plane.\n     */\n    constructor(normal: Vector) {\n        super();\n        this.normal = normal;\n    }\n\n    public intoRaw(): RawShape {\n        let n = VectorOps.intoRaw(this.normal);\n        let result = RawShape.halfspace(n);\n        n.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a box in 3D and a rectangle in 2D.\n */\nexport class Cuboid extends Shape {\n    readonly type = ShapeType.Cuboid;\n\n    /**\n     * The half extent of the cuboid along each coordinate axis.\n     */\n    halfExtents: Vector;\n\n\n    // #if DIM3\n    /**\n     * Creates a new 3D cuboid.\n     * @param hx - The half width of the cuboid.\n     * @param hy - The half height of the cuboid.\n     * @param hz - The half depth of the cuboid.\n     */\n    constructor(hx: number, hy: number, hz: number) {\n        super();\n        this.halfExtents = VectorOps.new(hx, hy, hz);\n    }\n\n    // #endif\n\n    public intoRaw(): RawShape {\n\n        // #if DIM3\n        return RawShape.cuboid(\n            this.halfExtents.x,\n            this.halfExtents.y,\n            this.halfExtents.z,\n        );\n        // #endif\n    }\n}\n\n/**\n * A shape that is a box in 3D and a rectangle in 2D, with round corners.\n */\nexport class RoundCuboid extends Shape {\n    readonly type = ShapeType.RoundCuboid;\n\n    /**\n     * The half extent of the cuboid along each coordinate axis.\n     */\n    halfExtents: Vector;\n\n    /**\n     * The radius of the cuboid's round border.\n     */\n    borderRadius: number;\n\n\n    // #if DIM3\n    /**\n     * Creates a new 3D cuboid.\n     * @param hx - The half width of the cuboid.\n     * @param hy - The half height of the cuboid.\n     * @param hz - The half depth of the cuboid.\n     * @param borderRadius - The radius of the borders of this cuboid. This will\n     *   effectively increase the half-extents of the cuboid by this radius.\n     */\n    constructor(hx: number, hy: number, hz: number, borderRadius: number) {\n        super();\n        this.halfExtents = VectorOps.new(hx, hy, hz);\n        this.borderRadius = borderRadius;\n    }\n\n    // #endif\n\n    public intoRaw(): RawShape {\n\n        // #if DIM3\n        return RawShape.roundCuboid(\n            this.halfExtents.x,\n            this.halfExtents.y,\n            this.halfExtents.z,\n            this.borderRadius,\n        );\n        // #endif\n    }\n}\n\n/**\n * A shape that is a capsule.\n */\nexport class Capsule extends Shape {\n    readonly type = ShapeType.Capsule;\n\n    /**\n     * The radius of the capsule's basis.\n     */\n    radius: number;\n\n    /**\n     * The capsule's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * Creates a new capsule with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight: number, radius: number) {\n        super();\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.capsule(this.halfHeight, this.radius);\n    }\n}\n\n/**\n * A shape that is a segment.\n */\nexport class Segment extends Shape {\n    readonly type = ShapeType.Segment;\n\n    /**\n     * The first point of the segment.\n     */\n    a: Vector;\n\n    /**\n     * The second point of the segment.\n     */\n    b: Vector;\n\n    /**\n     * Creates a new segment shape.\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    constructor(a: Vector, b: Vector) {\n        super();\n        this.a = a;\n        this.b = b;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let result = RawShape.segment(ra, rb);\n        ra.free();\n        rb.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a segment.\n */\nexport class Triangle extends Shape {\n    readonly type = ShapeType.Triangle;\n\n    /**\n     * The first point of the triangle.\n     */\n    a: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    b: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    c: Vector;\n\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    constructor(a: Vector, b: Vector, c: Vector) {\n        super();\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.triangle(ra, rb, rc);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a triangle with round borders and a non-zero thickness.\n */\nexport class RoundTriangle extends Shape {\n    readonly type = ShapeType.RoundTriangle;\n\n    /**\n     * The first point of the triangle.\n     */\n    a: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    b: Vector;\n\n    /**\n     * The second point of the triangle.\n     */\n    c: Vector;\n\n    /**\n     * The radius of the triangles's rounded edges and vertices.\n     * In 3D, this is also equal to half the thickness of the round triangle.\n     */\n    borderRadius: number;\n\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    constructor(a: Vector, b: Vector, c: Vector, borderRadius: number) {\n        super();\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.borderRadius = borderRadius;\n    }\n\n    public intoRaw(): RawShape {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.roundTriangle(ra, rb, rc, this.borderRadius);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n\n/**\n * A shape that is a triangle mesh.\n */\nexport class Polyline extends Shape {\n    readonly type = ShapeType.Polyline;\n\n    /**\n     * The vertices of the polyline.\n     */\n    vertices: Float32Array;\n\n    /**\n     * The indices of the segments.\n     */\n    indices: Uint32Array;\n\n    /**\n     * Creates a new polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `null` or not provided, then\n     *    the vertices are assumed to form a line strip.\n     */\n    constructor(vertices: Float32Array, indices?: Uint32Array) {\n        super();\n        this.vertices = vertices;\n        this.indices = indices ?? new Uint32Array(0);\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.polyline(this.vertices, this.indices);\n    }\n}\n\n/**\n * A shape that is a triangle mesh.\n */\nexport class TriMesh extends Shape {\n    readonly type = ShapeType.TriMesh;\n\n    /**\n     * The vertices of the triangle mesh.\n     */\n    vertices: Float32Array;\n\n    /**\n     * The indices of the triangles.\n     */\n    indices: Uint32Array;\n\n    /**\n     * Creates a new triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    constructor(vertices: Float32Array, indices: Uint32Array) {\n        super();\n        this.vertices = vertices;\n        this.indices = indices;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.trimesh(this.vertices, this.indices);\n    }\n}\n\n\n// #if DIM3\n/**\n * A shape that is a convex polygon.\n */\nexport class ConvexPolyhedron extends Shape {\n    readonly type = ShapeType.ConvexPolyhedron;\n\n    /**\n     * The vertices of the convex polygon.\n     */\n    vertices: Float32Array;\n\n    /**\n     * The indices of the convex polygon.\n     */\n    indices?: Uint32Array | null;\n\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param indices - The index buffer of this convex mesh. If this is `null`\n     *   or `undefined`, the convex-hull of the input vertices will be computed\n     *   automatically. Otherwise, it will be assumed that the mesh you provide\n     *   is already convex.\n     */\n    constructor(vertices: Float32Array, indices?: Uint32Array | null) {\n        super();\n        this.vertices = vertices;\n        this.indices = indices;\n    }\n\n    public intoRaw(): RawShape {\n        if (!!this.indices) {\n            return RawShape.convexMesh(this.vertices, this.indices);\n        } else {\n            return RawShape.convexHull(this.vertices);\n        }\n    }\n}\n\n/**\n * A shape that is a convex polygon.\n */\nexport class RoundConvexPolyhedron extends Shape {\n    readonly type = ShapeType.RoundConvexPolyhedron;\n\n    /**\n     * The vertices of the convex polygon.\n     */\n    vertices: Float32Array;\n\n    /**\n     * The indices of the convex polygon.\n     */\n    indices?: Uint32Array;\n\n    /**\n     * The radius of the convex polyhedron's rounded edges and vertices.\n     */\n    borderRadius: number;\n\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param indices - The index buffer of this convex mesh. If this is `null`\n     *   or `undefined`, the convex-hull of the input vertices will be computed\n     *   automatically. Otherwise, it will be assumed that the mesh you provide\n     *   is already convex.\n     * @param borderRadius - The radius of the borders of this convex polyhedron.\n     */\n    constructor(\n        vertices: Float32Array,\n        indices: Uint32Array | null | undefined,\n        borderRadius: number,\n    ) {\n        super();\n        this.vertices = vertices;\n        this.indices = indices;\n        this.borderRadius = borderRadius;\n    }\n\n    public intoRaw(): RawShape {\n        if (!!this.indices) {\n            return RawShape.roundConvexMesh(\n                this.vertices,\n                this.indices,\n                this.borderRadius,\n            );\n        } else {\n            return RawShape.roundConvexHull(this.vertices, this.borderRadius);\n        }\n    }\n}\n\n/**\n * A shape that is a heightfield.\n */\nexport class Heightfield extends Shape {\n    readonly type = ShapeType.HeightField;\n\n    /**\n     * The number of rows in the heights matrix.\n     */\n    nrows: number;\n\n    /**\n     * The number of columns in the heights matrix.\n     */\n    ncols: number;\n\n    /**\n     * The heights of the heightfield along its local `y` axis,\n     * provided as a matrix stored in column-major order.\n     */\n    heights: Float32Array;\n\n    /**\n     * The dimensions of the heightfield's local `x,z` plane.\n     */\n    scale: Vector;\n\n    /**\n     * Creates a new heightfield shape.\n     *\n     * @param nrows  The number of rows in the heights matrix.\n     * @param ncols - The number of columns in the heights matrix.\n     * @param heights - The heights of the heightfield along its local `y` axis,\n     *                  provided as a matrix stored in column-major order.\n     * @param scale - The dimensions of the heightfield's local `x,z` plane.\n     */\n    constructor(\n        nrows: number,\n        ncols: number,\n        heights: Float32Array,\n        scale: Vector,\n    ) {\n        super();\n        this.nrows = nrows;\n        this.ncols = ncols;\n        this.heights = heights;\n        this.scale = scale;\n    }\n\n    public intoRaw(): RawShape {\n        let rawScale = VectorOps.intoRaw(this.scale);\n        let rawShape = RawShape.heightfield(\n            this.nrows,\n            this.ncols,\n            this.heights,\n            rawScale,\n        );\n        rawScale.free();\n        return rawShape;\n    }\n}\n\n/**\n * A shape that is a 3D cylinder.\n */\nexport class Cylinder extends Shape {\n    readonly type = ShapeType.Cylinder;\n\n    /**\n     * The radius of the cylinder's basis.\n     */\n    radius: number;\n\n    /**\n     * The cylinder's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * Creates a new cylinder with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight: number, radius: number) {\n        super();\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.cylinder(this.halfHeight, this.radius);\n    }\n}\n\n/**\n * A shape that is a 3D cylinder with round corners.\n */\nexport class RoundCylinder extends Shape {\n    readonly type = ShapeType.RoundCylinder;\n\n    /**\n     * The radius of the cylinder's basis.\n     */\n    radius: number;\n\n    /**\n     * The cylinder's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * The radius of the cylinder's rounded edges and vertices.\n     */\n    borderRadius: number;\n\n    /**\n     * Creates a new cylinder with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     * @param borderRadius - The radius of the borders of this cylinder.\n     */\n    constructor(halfHeight: number, radius: number, borderRadius: number) {\n        super();\n        this.borderRadius = borderRadius;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.roundCylinder(\n            this.halfHeight,\n            this.radius,\n            this.borderRadius,\n        );\n    }\n}\n\n/**\n * A shape that is a 3D cone.\n */\nexport class Cone extends Shape {\n    readonly type = ShapeType.Cone;\n\n    /**\n     * The radius of the cone's basis.\n     */\n    radius: number;\n\n    /**\n     * The cone's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * Creates a new cone with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight: number, radius: number) {\n        super();\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.cone(this.halfHeight, this.radius);\n    }\n}\n\n/**\n * A shape that is a 3D cone with round corners.\n */\nexport class RoundCone extends Shape {\n    readonly type = ShapeType.RoundCone;\n\n    /**\n     * The radius of the cone's basis.\n     */\n    radius: number;\n\n    /**\n     * The cone's half height, along the `y` axis.\n     */\n    halfHeight: number;\n\n    /**\n     * The radius of the cylinder's rounded edges and vertices.\n     */\n    borderRadius: number;\n\n    /**\n     * Creates a new cone with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     * @param borderRadius - The radius of the borders of this cone.\n     */\n    constructor(halfHeight: number, radius: number, borderRadius: number) {\n        super();\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n        this.borderRadius = borderRadius;\n    }\n\n    public intoRaw(): RawShape {\n        return RawShape.roundCone(\n            this.halfHeight,\n            this.radius,\n            this.borderRadius,\n        );\n    }\n}\n\n// #endif\n","import {RawColliderSet} from \"../raw\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\nimport {\n    CoefficientCombineRule,\n    RigidBody,\n    RigidBodyHandle,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {ActiveHooks, ActiveEvents} from \"../pipeline\";\nimport {InteractionGroups} from \"./interaction_groups\";\nimport {\n    Shape,\n    Cuboid,\n    Ball,\n    ShapeType,\n    Capsule,\n    TriMesh,\n    Polyline,\n    Heightfield,\n    Segment,\n    Triangle,\n    RoundTriangle,\n    RoundCuboid,\n    HalfSpace,\n    // #if DIM3\n    Cylinder,\n    RoundCylinder,\n    Cone,\n    RoundCone,\n    ConvexPolyhedron,\n    RoundConvexPolyhedron,\n    // #endif\n} from \"./shape\";\nimport {Ray, RayIntersection} from \"./ray\";\nimport {PointProjection} from \"./point\";\nimport {ShapeColliderTOI, ShapeTOI} from \"./toi\";\nimport {ShapeContact} from \"./contact\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * Flags affecting whether collision-detection happens between two colliders\n * depending on the type of rigid-bodies they are attached to.\n */\nexport enum ActiveCollisionTypes {\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a dynamic body.\n     */\n    DYNAMIC_DYNAMIC = 0b0000_0000_0000_0001,\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a kinematic body.\n     */\n    DYNAMIC_KINEMATIC = 0b0000_0000_0000_1100,\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    DYNAMIC_FIXED = 0b0000_0000_0000_0010,\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a kinematic body.\n     */\n    KINEMATIC_KINEMATIC = 0b1100_1100_0000_0000,\n\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    KINEMATIC_FIXED = 0b0010_0010_0000_0000,\n\n    /**\n     * Enable collision-detection between a collider attached to a fixed body (or\n     * not attached to any body) and another collider attached to a fixed body (or\n     * not attached to any body).\n     */\n    FIXED_FIXED = 0b0000_0000_0010_0000,\n    /**\n     * The default active collision types, enabling collisions between a dynamic body\n     * and another body of any type, but not enabling collisions between two non-dynamic bodies.\n     */\n    DEFAULT = DYNAMIC_KINEMATIC | DYNAMIC_DYNAMIC | DYNAMIC_FIXED,\n    /**\n     * Enable collisions between any kind of rigid-bodies (including between two non-dynamic bodies).\n     */\n    ALL = DYNAMIC_KINEMATIC |\n        DYNAMIC_DYNAMIC |\n        DYNAMIC_FIXED |\n        KINEMATIC_KINEMATIC |\n        KINEMATIC_FIXED |\n        KINEMATIC_KINEMATIC,\n}\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type ColliderHandle = number;\n\n/**\n * A geometric entity that can be attached to a body so it can be affected\n * by contacts and proximity queries.\n */\nexport class Collider {\n    private colliderSet: ColliderSet; // The Collider won't need to free this.\n    readonly handle: ColliderHandle;\n    private _shape: Shape;\n    private _parent: RigidBody | null;\n\n    constructor(\n        colliderSet: ColliderSet,\n        handle: ColliderHandle,\n        parent: RigidBody | null,\n        shape?: Shape,\n    ) {\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n        this._parent = parent;\n        this._shape = shape;\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodies: RigidBodySet) {\n        if (this.handle != null) {\n            this._parent = bodies.get(\n                this.colliderSet.raw.coParent(this.handle),\n            );\n        }\n    }\n\n    private ensureShapeIsCached() {\n        if (!this._shape)\n            this._shape = Shape.fromRaw(this.colliderSet.raw, this.handle);\n    }\n\n    /**\n     * The shape of this collider.\n     */\n    public get shape(): Shape {\n        this.ensureShapeIsCached();\n        return this._shape;\n    }\n\n    /**\n     * Checks if this collider is still valid (i.e. that it has\n     * not been deleted from the collider set yet).\n     */\n    public isValid(): boolean {\n        return this.colliderSet.raw.contains(this.handle);\n    }\n\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    public translation(): Vector {\n        return VectorOps.fromRaw(\n            this.colliderSet.raw.coTranslation(this.handle),\n        );\n    }\n\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    public rotation(): Rotation {\n        return RotationOps.fromRaw(\n            this.colliderSet.raw.coRotation(this.handle),\n        );\n    }\n\n    /**\n     * Is this collider a sensor?\n     */\n    public isSensor(): boolean {\n        return this.colliderSet.raw.coIsSensor(this.handle);\n    }\n\n    /**\n     * Sets whether or not this collider is a sensor.\n     * @param isSensor - If `true`, the collider will be a sensor.\n     */\n    public setSensor(isSensor: boolean) {\n        this.colliderSet.raw.coSetSensor(this.handle, isSensor);\n    }\n\n    /**\n     * Sets the new shape of the collider.\n     * @param shape - The colliders new shape.\n     */\n    public setShape(shape: Shape) {\n        let rawShape = shape.intoRaw();\n        this.colliderSet.raw.coSetShape(this.handle, rawShape);\n        rawShape.free();\n        this._shape = shape;\n    }\n\n    /**\n     * Sets whether this collider is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this collider (its parent rigid-body wont be disabled automatically by this).\n     */\n    public setEnabled(enabled: boolean) {\n        this.colliderSet.raw.coSetEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Is this collider enabled?\n     */\n    public isEnabled(): boolean {\n        return this.colliderSet.raw.coIsEnabled(this.handle);\n    }\n\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    public setRestitution(restitution: number) {\n        this.colliderSet.raw.coSetRestitution(this.handle, restitution);\n    }\n\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    public setFriction(friction: number) {\n        this.colliderSet.raw.coSetFriction(this.handle, friction);\n    }\n\n    /**\n     * Gets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    public frictionCombineRule(): CoefficientCombineRule {\n        return this.colliderSet.raw.coFrictionCombineRule(this.handle);\n    }\n\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    public setFrictionCombineRule(rule: CoefficientCombineRule) {\n        this.colliderSet.raw.coSetFrictionCombineRule(this.handle, rule);\n    }\n\n    /**\n     * Gets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    public restitutionCombineRule(): CoefficientCombineRule {\n        return this.colliderSet.raw.coRestitutionCombineRule(this.handle);\n    }\n\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    public setRestitutionCombineRule(rule: CoefficientCombineRule) {\n        this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, rule);\n    }\n\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    public setCollisionGroups(groups: InteractionGroups) {\n        this.colliderSet.raw.coSetCollisionGroups(this.handle, groups);\n    }\n\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    public setSolverGroups(groups: InteractionGroups) {\n        this.colliderSet.raw.coSetSolverGroups(this.handle, groups);\n    }\n\n    /**\n     * Get the physics hooks active for this collider.\n     */\n    public activeHooks() {\n        return this.colliderSet.raw.coActiveHooks(this.handle);\n    }\n\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveHooks(activeHooks: ActiveHooks) {\n        this.colliderSet.raw.coSetActiveHooks(this.handle, activeHooks);\n    }\n\n    /**\n     * The events active for this collider.\n     */\n    public activeEvents(): ActiveEvents {\n        return this.colliderSet.raw.coActiveEvents(this.handle);\n    }\n\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    public setActiveEvents(activeEvents: ActiveEvents) {\n        this.colliderSet.raw.coSetActiveEvents(this.handle, activeEvents);\n    }\n\n    /**\n     * Gets the collision types active for this collider.\n     */\n    public activeCollisionTypes(): ActiveCollisionTypes {\n        return this.colliderSet.raw.coActiveCollisionTypes(this.handle);\n    }\n\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The new force threshold.\n     */\n    public setContactForceEventThreshold(threshold: number) {\n        return this.colliderSet.raw.coSetContactForceEventThreshold(\n            this.handle,\n            threshold,\n        );\n    }\n\n    /**\n     * The total force magnitude beyond which a contact force event can be emitted.\n     */\n    public contactForceEventThreshold(): number {\n        return this.colliderSet.raw.coContactForceEventThreshold(this.handle);\n    }\n\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveCollisionTypes(activeCollisionTypes: ActiveCollisionTypes) {\n        this.colliderSet.raw.coSetActiveCollisionTypes(\n            this.handle,\n            activeCollisionTypes,\n        );\n    }\n\n    /**\n     * Sets the uniform density of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The mass and angular inertia of this collider will be computed automatically based on its\n     * shape.\n     */\n    public setDensity(density: number) {\n        this.colliderSet.raw.coSetDensity(this.handle, density);\n    }\n\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The angular inertia of this collider will be computed automatically based on its shape\n     * and this mass value.\n     */\n    public setMass(mass: number) {\n        this.colliderSet.raw.coSetMass(this.handle, mass);\n    }\n\n    // #if DIM3\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     */\n    public setMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: Vector,\n        angularInertiaLocalFrame: Rotation,\n    ) {\n        let rawCom = VectorOps.intoRaw(centerOfMass);\n        let rawPrincipalInertia = VectorOps.intoRaw(principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(angularInertiaLocalFrame);\n\n        this.colliderSet.raw.coSetMassProperties(\n            this.handle,\n            mass,\n            rawCom,\n            rawPrincipalInertia,\n            rawInertiaFrame,\n        );\n\n        rawCom.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n    }\n    // #endif\n\n\n    /**\n     * Sets the translation of this collider.\n     *\n     * @param tra - The world-space position of the collider.\n     */\n    public setTranslation(tra: Vector) {\n        // #if DIM3\n        this.colliderSet.raw.coSetTranslation(this.handle, tra.x, tra.y, tra.z);\n        // #endif\n    }\n\n    /**\n     * Sets the translation of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param tra - The new translation of the collider relative to its parent.\n     */\n    public setTranslationWrtParent(tra: Vector) {\n        // #if DIM3\n        this.colliderSet.raw.coSetTranslationWrtParent(\n            this.handle,\n            tra.x,\n            tra.y,\n            tra.z,\n        );\n        // #endif\n    }\n\n    // #if DIM3\n    /**\n     * Sets the rotation quaternion of this collider.\n     *\n     * This does nothing if a zero quaternion is provided.\n     *\n     * @param rotation - The rotation to set.\n     */\n    public setRotation(rot: Rotation) {\n        this.colliderSet.raw.coSetRotation(\n            this.handle,\n            rot.x,\n            rot.y,\n            rot.z,\n            rot.w,\n        );\n    }\n\n    /**\n     * Sets the rotation quaternion of this collider relative to its parent rigid-body.\n     *\n     * This does nothing if a zero quaternion is provided or if this collider isn't\n     * attached to a rigid-body.\n     *\n     * @param rotation - The rotation to set.\n     */\n    public setRotationWrtParent(rot: Rotation) {\n        this.colliderSet.raw.coSetRotationWrtParent(\n            this.handle,\n            rot.x,\n            rot.y,\n            rot.z,\n            rot.w,\n        );\n    }\n    // #endif\n\n    /**\n     * The type of the shape of this collider.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public shapeType(): ShapeType {\n        return this.colliderSet.raw.coShapeType(this.handle);\n    }\n\n    /**\n     * The half-extents of this collider if it is a cuboid shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public halfExtents(): Vector {\n        return VectorOps.fromRaw(\n            this.colliderSet.raw.coHalfExtents(this.handle),\n        );\n    }\n\n    /**\n     * Sets the half-extents of this collider if it is a cuboid shape.\n     *\n     * @param newHalfExtents - desired half extents.\n     */\n    public setHalfExtents(newHalfExtents: Vector) {\n        const rawPoint = VectorOps.intoRaw(newHalfExtents);\n        this.colliderSet.raw.coSetHalfExtents(this.handle, rawPoint);\n    }\n\n    /**\n     * The radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public radius(): number {\n        return this.colliderSet.raw.coRadius(this.handle);\n    }\n\n    /**\n     * Sets the radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     *\n     * @param newRadius - desired radius.\n     */\n    public setRadius(newRadius: number): void {\n        this.colliderSet.raw.coSetRadius(this.handle, newRadius);\n    }\n\n    /**\n     * The radius of the round edges of this collider if it is a round cylinder.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public roundRadius(): number {\n        return this.colliderSet.raw.coRoundRadius(this.handle);\n    }\n\n    /**\n     * Sets the radius of the round edges of this collider if it has round edges.\n     *\n     * @param newBorderRadius - desired round edge radius.\n     */\n    public setRoundRadius(newBorderRadius: number) {\n        this.colliderSet.raw.coSetRoundRadius(this.handle, newBorderRadius);\n    }\n\n    /**\n     * The half height of this collider if it is a cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public halfHeight(): number {\n        return this.colliderSet.raw.coHalfHeight(this.handle);\n    }\n\n    /**\n     * Sets the half height of this collider if it is a cylinder, capsule, or cone shape.\n     *\n     * @param newHalfheight - desired half height.\n     */\n    public setHalfHeight(newHalfheight: number) {\n        this.colliderSet.raw.coSetHalfHeight(this.handle, newHalfheight);\n    }\n\n    /**\n     * If this collider has a triangle mesh, polyline, convex polygon, or convex polyhedron shape,\n     * this returns the vertex buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public vertices(): Float32Array {\n        return this.colliderSet.raw.coVertices(this.handle);\n    }\n\n    /**\n     * If this collider has a triangle mesh, polyline, or convex polyhedron shape,\n     * this returns the index buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public indices(): Uint32Array | undefined {\n        return this.colliderSet.raw.coIndices(this.handle);\n    }\n\n    /**\n     * If this collider has a heightfield shape, this returns the heights buffer of\n     * the heightfield.\n     * In 3D, the returned height matrix is provided in column-major order.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public heightfieldHeights(): Float32Array {\n        return this.colliderSet.raw.coHeightfieldHeights(this.handle);\n    }\n\n    /**\n     * If this collider has a heightfield shape, this returns the scale\n     * applied to it.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public heightfieldScale(): Vector {\n        let scale = this.colliderSet.raw.coHeightfieldScale(this.handle);\n        return VectorOps.fromRaw(scale);\n    }\n\n    // #if DIM3\n    /**\n     * If this collider has a heightfield shape, this returns the number of\n     * rows of its height matrix.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public heightfieldNRows(): number {\n        return this.colliderSet.raw.coHeightfieldNRows(this.handle);\n    }\n\n    /**\n     * If this collider has a heightfield shape, this returns the number of\n     * columns of its height matrix.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    public heightfieldNCols(): number {\n        return this.colliderSet.raw.coHeightfieldNCols(this.handle);\n    }\n\n    // #endif\n\n    /**\n     * The rigid-body this collider is attached to.\n     */\n    public parent(): RigidBody | null {\n        return this._parent;\n    }\n\n    /**\n     * The friction coefficient of this collider.\n     */\n    public friction(): number {\n        return this.colliderSet.raw.coFriction(this.handle);\n    }\n\n    /**\n     * The restitution coefficient of this collider.\n     */\n    public restitution(): number {\n        return this.colliderSet.raw.coRestitution(this.handle);\n    }\n\n    /**\n     * The density of this collider.\n     */\n    public density(): number {\n        return this.colliderSet.raw.coDensity(this.handle);\n    }\n\n    /**\n     * The mass of this collider.\n     */\n    public mass(): number {\n        return this.colliderSet.raw.coMass(this.handle);\n    }\n\n    /**\n     * The volume of this collider.\n     */\n    public volume(): number {\n        return this.colliderSet.raw.coVolume(this.handle);\n    }\n\n    /**\n     * The collision groups of this collider.\n     */\n    public collisionGroups(): InteractionGroups {\n        return this.colliderSet.raw.coCollisionGroups(this.handle);\n    }\n\n    /**\n     * The solver groups of this collider.\n     */\n    public solverGroups(): InteractionGroups {\n        return this.colliderSet.raw.coSolverGroups(this.handle);\n    }\n\n    /**\n     * Tests if this collider contains a point.\n     *\n     * @param point - The point to test.\n     */\n    public containsPoint(point: Vector): boolean {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = this.colliderSet.raw.coContainsPoint(\n            this.handle,\n            rawPoint,\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Find the projection of a point on this collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     */\n    public projectPoint(point: Vector, solid: boolean): PointProjection | null {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointProjection.fromRaw(\n            this.colliderSet.raw.coProjectPoint(this.handle, rawPoint, solid),\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Tests if this collider intersects the given ray.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     */\n    public intersectsRay(ray: Ray, maxToi: number): boolean {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coIntersectsRay(\n            this.handle,\n            rawOrig,\n            rawDir,\n            maxToi,\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /*\n     * Computes the smallest time between this and the given shape under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current shape to cast (i.e. the cast direction).\n     * @param shape2 - The shape to cast against.\n     * @param shape2Pos - The position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param shape2Vel - The constant velocity of the second shape.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `collider1Vel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     */\n    public castShape(\n        collider1Vel: Vector,\n        shape2: Shape,\n        shape2Pos: Vector,\n        shape2Rot: Rotation,\n        shape2Vel: Vector,\n        maxToi: number,\n        stopAtPenetration: boolean,\n    ): ShapeTOI | null {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawShape2Pos = VectorOps.intoRaw(shape2Pos);\n        let rawShape2Rot = RotationOps.intoRaw(shape2Rot);\n        let rawShape2Vel = VectorOps.intoRaw(shape2Vel);\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeTOI.fromRaw(\n            this.colliderSet,\n            this.colliderSet.raw.coCastShape(\n                this.handle,\n                rawCollider1Vel,\n                rawShape2,\n                rawShape2Pos,\n                rawShape2Rot,\n                rawShape2Vel,\n                maxToi,\n                stopAtPenetration,\n            ),\n        );\n\n        rawCollider1Vel.free();\n        rawShape2Pos.free();\n        rawShape2Rot.free();\n        rawShape2Vel.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /*\n     * Computes the smallest time between this and the given collider under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current collider to cast (i.e. the cast direction).\n     * @param collider2 - The collider to cast against.\n     * @param collider2Vel - The constant velocity of the second collider.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     */\n    public castCollider(\n        collider1Vel: Vector,\n        collider2: Collider,\n        collider2Vel: Vector,\n        maxToi: number,\n        stopAtPenetration: boolean,\n    ): ShapeColliderTOI | null {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawCollider2Vel = VectorOps.intoRaw(collider2Vel);\n\n        let result = ShapeColliderTOI.fromRaw(\n            this.colliderSet,\n            this.colliderSet.raw.coCastCollider(\n                this.handle,\n                rawCollider1Vel,\n                collider2.handle,\n                rawCollider2Vel,\n                maxToi,\n                stopAtPenetration,\n            ),\n        );\n\n        rawCollider1Vel.free();\n        rawCollider2Vel.free();\n\n        return result;\n    }\n\n    public intersectsShape(\n        shape2: Shape,\n        shapePos2: Vector,\n        shapeRot2: Rotation,\n    ): boolean {\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape2 = shape2.intoRaw();\n\n        let result = this.colliderSet.raw.coIntersectsShape(\n            this.handle,\n            rawShape2,\n            rawPos2,\n            rawRot2,\n        );\n\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Computes one pair of contact points between the shape owned by this collider and the given shape.\n     *\n     * @param shape2 - The second shape.\n     * @param shape2Pos - The initial position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(\n        shape2: Shape,\n        shape2Pos: Vector,\n        shape2Rot: Rotation,\n        prediction: number,\n    ): ShapeContact | null {\n        let rawPos2 = VectorOps.intoRaw(shape2Pos);\n        let rawRot2 = RotationOps.intoRaw(shape2Rot);\n        let rawShape2 = shape2.intoRaw();\n\n        let result = ShapeContact.fromRaw(\n            this.colliderSet.raw.coContactShape(\n                this.handle,\n                rawShape2,\n                rawPos2,\n                rawRot2,\n                prediction,\n            ),\n        );\n\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n\n        return result;\n    }\n\n    /**\n     * Computes one pair of contact points between the collider and the given collider.\n     *\n     * @param collider2 - The second collider.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactCollider(\n        collider2: Collider,\n        prediction: number,\n    ): ShapeContact | null {\n        let result = ShapeContact.fromRaw(\n            this.colliderSet.raw.coContactCollider(\n                this.handle,\n                collider2.handle,\n                prediction,\n            ),\n        );\n\n        return result;\n    }\n\n    /*\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @returns The time-of-impact between this collider and the ray, or `-1` if there is no intersection.\n     */\n    public castRay(ray: Ray, maxToi: number, solid: boolean): number {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coCastRay(\n            this.handle,\n            rawOrig,\n            rawDir,\n            maxToi,\n            solid,\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /**\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     */\n    public castRayAndGetNormal(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n    ): RayIntersection | null {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayIntersection.fromRaw(\n            this.colliderSet.raw.coCastRayAndGetNormal(\n                this.handle,\n                rawOrig,\n                rawDir,\n                maxToi,\n                solid,\n            ),\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n}\n\nexport enum MassPropsMode {\n    Density,\n    Mass,\n    MassProps,\n}\n\nexport class ColliderDesc {\n    enabled: boolean;\n    shape: Shape;\n    massPropsMode: MassPropsMode;\n    mass: number;\n    centerOfMass: Vector;\n    // #if DIM3\n    principalAngularInertia: Vector;\n    angularInertiaLocalFrame: Rotation;\n    // #endif\n    density: number;\n    friction: number;\n    restitution: number;\n    rotation: Rotation;\n    translation: Vector;\n    isSensor: boolean;\n    collisionGroups: InteractionGroups;\n    solverGroups: InteractionGroups;\n    frictionCombineRule: CoefficientCombineRule;\n    restitutionCombineRule: CoefficientCombineRule;\n    activeEvents: ActiveEvents;\n    activeHooks: ActiveHooks;\n    activeCollisionTypes: ActiveCollisionTypes;\n    contactForceEventThreshold: number;\n\n    /**\n     * Initializes a collider descriptor from the collision shape.\n     *\n     * @param shape - The shape of the collider being built.\n     */\n    constructor(shape: Shape) {\n        this.enabled = true;\n        this.shape = shape;\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = 1.0;\n        this.friction = 0.5;\n        this.restitution = 0.0;\n        this.rotation = RotationOps.identity();\n        this.translation = VectorOps.zeros();\n        this.isSensor = false;\n        this.collisionGroups = 0xffff_ffff;\n        this.solverGroups = 0xffff_ffff;\n        this.frictionCombineRule = CoefficientCombineRule.Average;\n        this.restitutionCombineRule = CoefficientCombineRule.Average;\n        this.activeCollisionTypes = ActiveCollisionTypes.DEFAULT;\n        this.activeEvents = 0;\n        this.activeHooks = 0;\n        this.mass = 0.0;\n        this.centerOfMass = VectorOps.zeros();\n        this.contactForceEventThreshold = 0.0;\n\n        // #if DIM3\n        this.principalAngularInertia = VectorOps.zeros();\n        this.angularInertiaLocalFrame = RotationOps.identity();\n        // #endif\n    }\n\n    /**\n     * Create a new collider descriptor with a ball shape.\n     *\n     * @param radius - The radius of the ball.\n     */\n    public static ball(radius: number): ColliderDesc {\n        const shape = new Ball(radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a capsule shape.\n     *\n     * @param halfHeight - The half-height of the capsule, along the `y` axis.\n     * @param radius - The radius of the capsule basis.\n     */\n    public static capsule(halfHeight: number, radius: number): ColliderDesc {\n        const shape = new Capsule(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new segment shape.\n     *\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    public static segment(a: Vector, b: Vector): ColliderDesc {\n        const shape = new Segment(a, b);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    public static triangle(a: Vector, b: Vector, c: Vector): ColliderDesc {\n        const shape = new Triangle(a, b, c);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    public static roundTriangle(\n        a: Vector,\n        b: Vector,\n        c: Vector,\n        borderRadius: number,\n    ): ColliderDesc {\n        const shape = new RoundTriangle(a, b, c, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `undefined` or `null`,\n     *    the vertices are assumed to describe a line strip.\n     */\n    public static polyline(\n        vertices: Float32Array,\n        indices?: Uint32Array | null,\n    ): ColliderDesc {\n        const shape = new Polyline(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    public static trimesh(\n        vertices: Float32Array,\n        indices: Uint32Array,\n    ): ColliderDesc {\n        const shape = new TriMesh(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n\n\n    // #if DIM3\n    /**\n     * Creates a new collider descriptor with a cuboid shape.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param hz - The half-width of the rectangle along its local `z` axis.\n     */\n    public static cuboid(hx: number, hy: number, hz: number): ColliderDesc {\n        const shape = new Cuboid(hx, hy, hz);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a rectangular shape with round borders.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param hz - The half-width of the rectangle along its local `z` axis.\n     * @param borderRadius - The radius of the cuboid's borders.\n     */\n    public static roundCuboid(\n        hx: number,\n        hy: number,\n        hz: number,\n        borderRadius: number,\n    ): ColliderDesc {\n        const shape = new RoundCuboid(hx, hy, hz, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor with a heightfield shape.\n     *\n     * @param nrows  The number of rows in the heights matrix.\n     * @param ncols - The number of columns in the heights matrix.\n     * @param heights - The heights of the heightfield along its local `y` axis,\n     *                  provided as a matrix stored in column-major order.\n     * @param scale - The scale factor applied to the heightfield.\n     */\n    public static heightfield(\n        nrows: number,\n        ncols: number,\n        heights: Float32Array,\n        scale: Vector,\n    ): ColliderDesc {\n        const shape = new Heightfield(nrows, ncols, heights, scale);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a cylinder shape.\n     *\n     * @param halfHeight - The half-height of the cylinder, along the `y` axis.\n     * @param radius - The radius of the cylinder basis.\n     */\n    public static cylinder(halfHeight: number, radius: number): ColliderDesc {\n        const shape = new Cylinder(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a cylinder shape with rounded corners.\n     *\n     * @param halfHeight - The half-height of the cylinder, along the `y` axis.\n     * @param radius - The radius of the cylinder basis.\n     * @param borderRadius - The radius of the cylinder's rounded edges and vertices.\n     */\n    public static roundCylinder(\n        halfHeight: number,\n        radius: number,\n        borderRadius: number,\n    ): ColliderDesc {\n        const shape = new RoundCylinder(halfHeight, radius, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a cone shape.\n     *\n     * @param halfHeight - The half-height of the cone, along the `y` axis.\n     * @param radius - The radius of the cone basis.\n     */\n    public static cone(halfHeight: number, radius: number): ColliderDesc {\n        const shape = new Cone(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Create a new collider descriptor with a cone shape with rounded corners.\n     *\n     * @param halfHeight - The half-height of the cone, along the `y` axis.\n     * @param radius - The radius of the cone basis.\n     * @param borderRadius - The radius of the cone's rounded edges and vertices.\n     */\n    public static roundCone(\n        halfHeight: number,\n        radius: number,\n        borderRadius: number,\n    ): ColliderDesc {\n        const shape = new RoundCone(halfHeight, radius, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polyhedron as the shape for this new collider descriptor.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     */\n    public static convexHull(points: Float32Array): ColliderDesc | null {\n        const shape = new ConvexPolyhedron(points, null);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     */\n    public static convexMesh(\n        vertices: Float32Array,\n        indices?: Uint32Array | null,\n    ): ColliderDesc | null {\n        const shape = new ConvexPolyhedron(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polyhedron as the shape for this new collider descriptor. A\n     * border is added to that convex polyhedron to give it round corners.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     * @param borderRadius - The radius of the round border added to the convex polyhedron.\n     */\n    public static roundConvexHull(\n        points: Float32Array,\n        borderRadius: number,\n    ): ColliderDesc | null {\n        const shape = new RoundConvexPolyhedron(points, null, borderRadius);\n        return new ColliderDesc(shape);\n    }\n\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a round convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     * @param borderRadius - The radius of the round border added to the convex polyline.\n     */\n    public static roundConvexMesh(\n        vertices: Float32Array,\n        indices: Uint32Array | null,\n        borderRadius: number,\n    ): ColliderDesc | null {\n        const shape = new RoundConvexPolyhedron(\n            vertices,\n            indices,\n            borderRadius,\n        );\n        return new ColliderDesc(shape);\n    }\n\n    // #endif\n\n\n    // #if DIM3\n    /**\n     * Sets the position of the collider to be created relative to the rigid-body it is attached to.\n     */\n    public setTranslation(x: number, y: number, z: number): ColliderDesc {\n        if (\n            typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\"\n        )\n            throw TypeError(\"The translation components must be numbers.\");\n\n        this.translation = {x: x, y: y, z: z};\n        return this;\n    }\n\n    // #endif\n\n    /**\n     * Sets the rotation of the collider to be created relative to the rigid-body it is attached to.\n     *\n     * @param rot - The rotation of the collider to be created relative to the rigid-body it is attached to.\n     */\n    public setRotation(rot: Rotation): ColliderDesc {\n        // #if DIM3\n        RotationOps.copy(this.rotation, rot);\n        // #endif\n        return this;\n    }\n\n    /**\n     * Sets whether or not the collider being created is a sensor.\n     *\n     * A sensor collider does not take part of the physics simulation, but generates\n     * proximity events.\n     *\n     * @param sensor - Set to `true` of the collider built is to be a sensor.\n     */\n    public setSensor(sensor: boolean): ColliderDesc {\n        this.isSensor = sensor;\n        return this;\n    }\n\n    /**\n     * Sets whether the created collider will be enabled or disabled.\n     * @param enabled  If set to `false` the collider will be disabled at creation.\n     */\n    public setEnabled(enabled: boolean): ColliderDesc {\n        this.enabled = enabled;\n        return this;\n    }\n\n    /**\n     * Sets the density of the collider being built.\n     *\n     * The mass and angular inertia tensor will be computed automatically based on this density and the colliders shape.\n     *\n     * @param density - The density to set, must be greater or equal to 0. A density of 0 means that this collider\n     *                  will not affect the mass or angular inertia of the rigid-body it is attached to.\n     */\n    public setDensity(density: number): ColliderDesc {\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = density;\n        return this;\n    }\n\n    /**\n     * Sets the mass of the collider being built.\n     *\n     * The angular inertia tensor will be computed automatically based on this mass and the colliders shape.\n     *\n     * @param mass - The mass to set, must be greater or equal to 0.\n     */\n    public setMass(mass: number): ColliderDesc {\n        this.massPropsMode = MassPropsMode.Mass;\n        this.mass = mass;\n        return this;\n    }\n\n\n    // #if DIM3\n    /**\n     * Sets the mass properties of the collider being built.\n     *\n     * This replaces the mass-properties automatically computed from the collider's density and shape.\n     * These mass-properties will be added to the mass-properties of the rigid-body this collider will be attached to.\n     *\n     * @param mass  The mass of the collider to create.\n     * @param centerOfMass  The center-of-mass of the collider to create.\n     * @param principalAngularInertia  The initial principal angular inertia of the collider to create.\n     *                                  These are the eigenvalues of the angular inertia matrix.\n     * @param angularInertiaLocalFrame  The initial local angular inertia frame of the collider to create.\n     *                                   These are the eigenvectors of the angular inertia matrix.\n     */\n    public setMassProperties(\n        mass: number,\n        centerOfMass: Vector,\n        principalAngularInertia: Vector,\n        angularInertiaLocalFrame: Rotation,\n    ): ColliderDesc {\n        this.massPropsMode = MassPropsMode.MassProps;\n        this.mass = mass;\n        VectorOps.copy(this.centerOfMass, centerOfMass);\n        VectorOps.copy(this.principalAngularInertia, principalAngularInertia);\n        RotationOps.copy(\n            this.angularInertiaLocalFrame,\n            angularInertiaLocalFrame,\n        );\n        return this;\n    }\n    // #endif\n\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    public setRestitution(restitution: number): ColliderDesc {\n        this.restitution = restitution;\n        return this;\n    }\n\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    public setFriction(friction: number): ColliderDesc {\n        this.friction = friction;\n        return this;\n    }\n\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    public setFrictionCombineRule(rule: CoefficientCombineRule): ColliderDesc {\n        this.frictionCombineRule = rule;\n        return this;\n    }\n\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    public setRestitutionCombineRule(\n        rule: CoefficientCombineRule,\n    ): ColliderDesc {\n        this.restitutionCombineRule = rule;\n        return this;\n    }\n\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    public setCollisionGroups(groups: InteractionGroups): ColliderDesc {\n        this.collisionGroups = groups;\n        return this;\n    }\n\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    public setSolverGroups(groups: InteractionGroups): ColliderDesc {\n        this.solverGroups = groups;\n        return this;\n    }\n\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveHooks(activeHooks: ActiveHooks): ColliderDesc {\n        this.activeHooks = activeHooks;\n        return this;\n    }\n\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    public setActiveEvents(activeEvents: ActiveEvents): ColliderDesc {\n        this.activeEvents = activeEvents;\n        return this;\n    }\n\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    public setActiveCollisionTypes(\n        activeCollisionTypes: ActiveCollisionTypes,\n    ): ColliderDesc {\n        this.activeCollisionTypes = activeCollisionTypes;\n        return this;\n    }\n\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The force threshold to set.\n     */\n    public setContactForceEventThreshold(threshold: number): ColliderDesc {\n        this.contactForceEventThreshold = threshold;\n        return this;\n    }\n}\n","import {RawQueryPipeline, RawRayColliderIntersection} from \"../raw\";\nimport {\n    ColliderHandle,\n    ColliderSet,\n    InteractionGroups,\n    PointColliderProjection,\n    Ray,\n    RayColliderIntersection,\n    RayColliderToi,\n    Shape,\n    ShapeColliderTOI,\n} from \"../geometry\";\nimport {IslandManager, RigidBodyHandle, RigidBodySet} from \"../dynamics\";\nimport {Rotation, RotationOps, Vector, VectorOps} from \"../math\";\n\n// NOTE: must match the bits in the QueryFilterFlags on the Rust side.\n/**\n * Flags for excluding whole sets of colliders from a scene query.\n */\nexport enum QueryFilterFlags {\n    /**\n     * Exclude from the query any collider attached to a fixed rigid-body and colliders with no rigid-body attached.\n     */\n    EXCLUDE_FIXED = 0b0000_0001,\n    /**\n     * Exclude from the query any collider attached to a dynamic rigid-body.\n     */\n    EXCLUDE_KINEMATIC = 0b0000_0010,\n    /**\n     * Exclude from the query any collider attached to a kinematic rigid-body.\n     */\n    EXCLUDE_DYNAMIC = 0b0000_0100,\n    /**\n     * Exclude from the query any collider that is a sensor.\n     */\n    EXCLUDE_SENSORS = 0b0000_1000,\n    /**\n     * Exclude from the query any collider that is not a sensor.\n     */\n    EXCLUDE_SOLIDS = 0b0001_0000,\n    /**\n     * Excludes all colliders not attached to a dynamic rigid-body.\n     */\n    ONLY_DYNAMIC = QueryFilterFlags.EXCLUDE_FIXED |\n        QueryFilterFlags.EXCLUDE_KINEMATIC,\n    /**\n     * Excludes all colliders not attached to a kinematic rigid-body.\n     */\n    ONLY_KINEMATIC = QueryFilterFlags.EXCLUDE_DYNAMIC |\n        QueryFilterFlags.EXCLUDE_FIXED,\n    /**\n     * Exclude all colliders attached to a non-fixed rigid-body\n     * (this will not exclude colliders not attached to any rigid-body).\n     */\n    ONLY_FIXED = QueryFilterFlags.EXCLUDE_DYNAMIC |\n        QueryFilterFlags.EXCLUDE_KINEMATIC,\n}\n\n/**\n * A pipeline for performing queries on all the colliders of a scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class QueryPipeline {\n    raw: RawQueryPipeline;\n\n    /**\n     * Release the WASM memory occupied by this query pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawQueryPipeline) {\n        this.raw = raw || new RawQueryPipeline();\n    }\n\n    /**\n     * Updates the acceleration structure of the query pipeline.\n     * @param bodies - The set of rigid-bodies taking part in this pipeline.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     */\n    public update(bodies: RigidBodySet, colliders: ColliderSet) {\n        this.raw.update(bodies.raw, colliders.raw);\n    }\n\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    public castRay(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): RayColliderToi | null {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderToi.fromRaw(\n            colliders,\n            this.raw.castRay(\n                bodies.raw,\n                colliders.raw,\n                rawOrig,\n                rawDir,\n                maxToi,\n                solid,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    public castRayAndGetNormal(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): RayColliderIntersection | null {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderIntersection.fromRaw(\n            colliders,\n            this.raw.castRayAndGetNormal(\n                bodies.raw,\n                colliders.raw,\n                rawOrig,\n                rawDir,\n                maxToi,\n                solid,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawOrig.free();\n        rawDir.free();\n\n        return result;\n    }\n\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    public intersectionsWithRay(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        callback: (intersect: RayColliderIntersection) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let rawCallback = (rawInter: RawRayColliderIntersection) => {\n            return callback(\n                RayColliderIntersection.fromRaw(colliders, rawInter),\n            );\n        };\n\n        this.raw.intersectionsWithRay(\n            bodies.raw,\n            colliders.raw,\n            rawOrig,\n            rawDir,\n            maxToi,\n            solid,\n            rawCallback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawOrig.free();\n        rawDir.free();\n    }\n\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    public intersectionWithShape(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): ColliderHandle | null {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        let result = this.raw.intersectionWithShape(\n            bodies.raw,\n            colliders.raw,\n            rawPos,\n            rawRot,\n            rawShape,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPoint(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        point: Vector,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): PointColliderProjection | null {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(\n            colliders,\n            this.raw.projectPoint(\n                bodies.raw,\n                colliders.raw,\n                rawPoint,\n                solid,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPointAndGetFeature(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        point: Vector,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): PointColliderProjection | null {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(\n            colliders,\n            this.raw.projectPointAndGetFeature(\n                bodies.raw,\n                colliders.raw,\n                rawPoint,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawPoint.free();\n\n        return result;\n    }\n\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    public intersectionsWithPoint(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        point: Vector,\n        callback: (handle: ColliderHandle) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ) {\n        let rawPoint = VectorOps.intoRaw(point);\n\n        this.raw.intersectionsWithPoint(\n            bodies.raw,\n            colliders.raw,\n            rawPoint,\n            callback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawPoint.free();\n    }\n\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    public castShape(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shapeVel: Vector,\n        shape: Shape,\n        maxToi: number,\n        stopAtPenetration: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ): ShapeColliderTOI | null {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawVel = VectorOps.intoRaw(shapeVel);\n        let rawShape = shape.intoRaw();\n\n        let result = ShapeColliderTOI.fromRaw(\n            colliders,\n            this.raw.castShape(\n                bodies.raw,\n                colliders.raw,\n                rawPos,\n                rawRot,\n                rawVel,\n                rawShape,\n                maxToi,\n                stopAtPenetration,\n                filterFlags,\n                filterGroups,\n                filterExcludeCollider,\n                filterExcludeRigidBody,\n                filterPredicate,\n            ),\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawVel.free();\n        rawShape.free();\n\n        return result;\n    }\n\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    public intersectionsWithShape(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        callback: (handle: ColliderHandle) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: ColliderHandle,\n        filterExcludeRigidBody?: RigidBodyHandle,\n        filterPredicate?: (collider: ColliderHandle) => boolean,\n    ) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n\n        this.raw.intersectionsWithShape(\n            bodies.raw,\n            colliders.raw,\n            rawPos,\n            rawRot,\n            rawShape,\n            callback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider,\n            filterExcludeRigidBody,\n            filterPredicate,\n        );\n\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n    }\n\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    public collidersWithAabbIntersectingAabb(\n        aabbCenter: Vector,\n        aabbHalfExtents: Vector,\n        callback: (handle: ColliderHandle) => boolean,\n    ) {\n        let rawCenter = VectorOps.intoRaw(aabbCenter);\n        let rawHalfExtents = VectorOps.intoRaw(aabbHalfExtents);\n        this.raw.collidersWithAabbIntersectingAabb(\n            rawCenter,\n            rawHalfExtents,\n            callback,\n        );\n        rawCenter.free();\n        rawHalfExtents.free();\n    }\n}\n","import {RawContactForceEvent, RawEventQueue} from \"../raw\";\nimport {RigidBodyHandle} from \"../dynamics\";\nimport {Collider, ColliderHandle} from \"../geometry\";\nimport {Vector, VectorOps} from \"../math\";\n\n/**\n * Flags indicating what events are enabled for colliders.\n */\nexport enum ActiveEvents {\n    /**\n     * Enable collision events.\n     */\n    COLLISION_EVENTS = 0b0001,\n    /**\n     * Enable contact force events.\n     */\n    CONTACT_FORCE_EVENTS = 0b0010,\n}\n\n/**\n * Event occurring when the sum of the magnitudes of the\n * contact forces between two colliders exceed a threshold.\n *\n * This object should **not** be stored anywhere. Its properties can only be\n * read from within the closure given to `EventHandler.drainContactForceEvents`.\n */\nexport class TempContactForceEvent {\n    raw: RawContactForceEvent;\n\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    /**\n     * The first collider involved in the contact.\n     */\n    public collider1(): ColliderHandle {\n        return this.raw.collider1();\n    }\n\n    /**\n     * The second collider involved in the contact.\n     */\n    public collider2(): ColliderHandle {\n        return this.raw.collider2();\n    }\n\n    /**\n     * The sum of all the forces between the two colliders.\n     */\n    public totalForce(): Vector {\n        return VectorOps.fromRaw(this.raw.total_force());\n    }\n\n    /**\n     * The sum of the magnitudes of each force between the two colliders.\n     *\n     * Note that this is **not** the same as the magnitude of `self.total_force`.\n     * Here we are summing the magnitude of all the forces, instead of taking\n     * the magnitude of their sum.\n     */\n    public totalForceMagnitude(): number {\n        return this.raw.total_force_magnitude();\n    }\n\n    /**\n     * The world-space (unit) direction of the force with strongest magnitude.\n     */\n    public maxForceDirection(): Vector {\n        return VectorOps.fromRaw(this.raw.max_force_direction());\n    }\n\n    /**\n     * The magnitude of the largest force at a contact point of this contact pair.\n     */\n    public maxForceMagnitude(): number {\n        return this.raw.max_force_magnitude();\n    }\n}\n\n/**\n * A structure responsible for collecting events generated\n * by the physics engine.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `eventQueue.free()`\n * once you are done using it.\n */\nexport class EventQueue {\n    raw: RawEventQueue;\n\n    /**\n     * Creates a new event collector.\n     *\n     * @param autoDrain -setting this to `true` is strongly recommended. If true, the collector will\n     * be automatically drained before each `world.step(collector)`. If false, the collector will\n     * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n     * RAM if no drain is performed.\n     */\n    constructor(autoDrain: boolean, raw?: RawEventQueue) {\n        this.raw = raw || new RawEventQueue(autoDrain);\n    }\n\n    /**\n     * Release the WASM memory occupied by this event-queue.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    /**\n     * Applies the given javascript closure on each collision event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     * closure must take three arguments: two integers representing the handles of the colliders\n     * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n     * (false).\n     */\n    public drainCollisionEvents(\n        f: (\n            handle1: ColliderHandle,\n            handle2: ColliderHandle,\n            started: boolean,\n        ) => void,\n    ) {\n        this.raw.drainCollisionEvents(f);\n    }\n\n    /**\n     * Applies the given javascript closure on each contact force event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     *            closure must take one `TempContactForceEvent` argument.\n     */\n    public drainContactForceEvents(f: (event: TempContactForceEvent) => void) {\n        let event = new TempContactForceEvent();\n        this.raw.drainContactForceEvents((raw: RawContactForceEvent) => {\n            event.raw = raw;\n            f(event);\n            event.free();\n        });\n    }\n\n    /**\n     * Removes all events contained by this collector\n     */\n    public clear() {\n        this.raw.clear();\n    }\n}\n","import {RigidBodyHandle} from \"../dynamics\";\nimport {ColliderHandle} from \"../geometry\";\n\nexport enum ActiveHooks {\n    FILTER_CONTACT_PAIRS = 0b0001,\n    FILTER_INTERSECTION_PAIRS = 0b0010,\n    // MODIFY_SOLVER_CONTACTS = 0b0100, /* Not supported yet in JS. */\n}\n\nexport enum SolverFlags {\n    EMPTY = 0b000,\n    COMPUTE_IMPULSE = 0b001,\n}\n\nexport interface PhysicsHooks {\n    /**\n     * Function that determines if contacts computation should happen between two colliders, and how the\n     * constraints solver should behave for these contacts.\n     *\n     * This will only be executed and taken into account if at least one of the involved colliders contains the\n     * `ActiveHooks.FILTER_CONTACT_PAIR` flag in its active hooks.\n     *\n     * @param collider1  Handle of the first collider involved in the potential contact.\n     * @param collider2  Handle of the second collider involved in the potential contact.\n     * @param body1  Handle of the first body involved in the potential contact.\n     * @param body2  Handle of the second body involved in the potential contact.\n     */\n    filterContactPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n        body1: RigidBodyHandle,\n        body2: RigidBodyHandle,\n    ): SolverFlags | null;\n\n    /**\n     * Function that determines if intersection computation should happen between two colliders (where at least\n     * one is a sensor).\n     *\n     * This will only be executed and taken into account if `one of the involved colliders contains the\n     * `ActiveHooks.FILTER_INTERSECTION_PAIR` flag in its active hooks.\n     *\n     * @param collider1  Handle of the first collider involved in the potential contact.\n     * @param collider2  Handle of the second collider involved in the potential contact.\n     * @param body1  Handle of the first body involved in the potential contact.\n     * @param body2  Handle of the second body involved in the potential contact.\n     */\n    filterIntersectionPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n        body1: RigidBodyHandle,\n        body2: RigidBodyHandle,\n    ): boolean;\n}\n","export class Coarena<T> {\n    fconv: Float64Array;\n    uconv: Uint32Array;\n    data: Array<T>;\n    size: number;\n\n    public constructor() {\n        this.fconv = new Float64Array(1);\n        this.uconv = new Uint32Array(this.fconv.buffer);\n        this.data = new Array<T>();\n        this.size = 0;\n    }\n\n    public set(handle: number, data: T) {\n        let i = this.index(handle);\n        while (this.data.length <= i) {\n            this.data.push(null);\n        }\n\n        if (this.data[i] == null) this.size += 1;\n        this.data[i] = data;\n    }\n\n    public len(): number {\n        return this.size;\n    }\n\n    public delete(handle: number) {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            if (this.data[i] != null) this.size -= 1;\n            this.data[i] = null;\n        }\n    }\n\n    public clear() {\n        this.data = new Array<T>();\n    }\n\n    public get(handle: number): T | null {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            return this.data[i];\n        } else {\n            return null;\n        }\n    }\n\n    public forEach(f: (elt: T) => void) {\n        for (const elt of this.data) {\n            if (elt != null) f(elt);\n        }\n    }\n\n    public getAll(): Array<T> {\n        return this.data.filter((elt) => elt != null);\n    }\n\n    private index(handle: number): number {\n        /// Extracts the index part of a handle (the lower 32 bits).\n        /// This is done by first injecting the handle into an Float64Array\n        /// which is itself injected into an Uint32Array (at construction time).\n        /// The 0-th value of the Uint32Array will become the `number` integer\n        /// representation of the lower 32 bits.\n        /// Also `this.uconv[1]` then contains the generation number as a `number`,\n        /// which we dont really need.\n        this.fconv[0] = handle;\n        return this.uconv[0];\n    }\n}\n","import {RawRigidBodySet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {VectorOps, RotationOps} from \"../math\";\nimport {RigidBody, RigidBodyDesc, RigidBodyHandle} from \"./rigid_body\";\nimport {ColliderSet} from \"../geometry\";\nimport {ImpulseJointSet} from \"./impulse_joint_set\";\nimport {MultibodyJointSet} from \"./multibody_joint_set\";\nimport {IslandManager} from \"./island_manager\";\n\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `rigidBodySet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class RigidBodySet {\n    raw: RawRigidBodySet;\n    private map: Coarena<RigidBody>;\n\n    /**\n     * Release the WASM memory occupied by this rigid-body set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawRigidBodySet) {\n        this.raw = raw || new RawRigidBodySet();\n        this.map = new Coarena<RigidBody>();\n        // deserialize\n        if (raw) {\n            raw.forEachRigidBodyHandle((handle: RigidBodyHandle) => {\n                this.map.set(handle, new RigidBody(raw, null, handle));\n            });\n        }\n    }\n\n    /**\n     * Internal method, do not call this explicitly.\n     */\n    public finalizeDeserialization(colliderSet: ColliderSet) {\n        this.map.forEach((rb) => rb.finalizeDeserialization(colliderSet));\n    }\n\n    /**\n     * Creates a new rigid-body and return its integer handle.\n     *\n     * @param desc - The description of the rigid-body to create.\n     */\n    public createRigidBody(\n        colliderSet: ColliderSet,\n        desc: RigidBodyDesc,\n    ): RigidBody {\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawLv = VectorOps.intoRaw(desc.linvel);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n\n        // #if DIM3\n        let rawAv = VectorOps.intoRaw(desc.angvel);\n        let rawPrincipalInertia = VectorOps.intoRaw(\n            desc.principalAngularInertia,\n        );\n        let rawInertiaFrame = RotationOps.intoRaw(\n            desc.angularInertiaLocalFrame,\n        );\n        // #endif\n\n        let handle = this.raw.createRigidBody(\n            desc.enabled,\n            rawTra,\n            rawRot,\n            desc.gravityScale,\n            desc.mass,\n            desc.massOnly,\n            rawCom,\n            rawLv,\n            // #if DIM3\n            rawAv,\n            rawPrincipalInertia,\n            rawInertiaFrame,\n            desc.translationsEnabledX,\n            desc.translationsEnabledY,\n            desc.translationsEnabledZ,\n            desc.rotationsEnabledX,\n            desc.rotationsEnabledY,\n            desc.rotationsEnabledZ,\n            // #endif\n            desc.linearDamping,\n            desc.angularDamping,\n            desc.status,\n            desc.canSleep,\n            desc.sleeping,\n            desc.ccdEnabled,\n            desc.dominanceGroup,\n        );\n\n        rawTra.free();\n        rawRot.free();\n        rawLv.free();\n        rawCom.free();\n\n        // #if DIM3\n        rawAv.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n        // #endif\n\n        const body = new RigidBody(this.raw, colliderSet, handle);\n        body.userData = desc.userData;\n\n        this.map.set(handle, body);\n\n        return body;\n    }\n\n    /**\n     * Removes a rigid-body from this set.\n     *\n     * This will also remove all the colliders and joints attached to the rigid-body.\n     *\n     * @param handle - The integer handle of the rigid-body to remove.\n     * @param colliders - The set of colliders that may contain colliders attached to the removed rigid-body.\n     * @param impulseJoints - The set of impulse joints that may contain joints attached to the removed rigid-body.\n     * @param multibodyJoints - The set of multibody joints that may contain joints attached to the removed rigid-body.\n     */\n    public remove(\n        handle: RigidBodyHandle,\n        islands: IslandManager,\n        colliders: ColliderSet,\n        impulseJoints: ImpulseJointSet,\n        multibodyJoints: MultibodyJointSet,\n    ) {\n        // Unmap the entities that will be removed automatically because of the rigid-body removals.\n        for (let i = 0; i < this.raw.rbNumColliders(handle); i += 1) {\n            colliders.unmap(this.raw.rbCollider(handle, i));\n        }\n\n        impulseJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) =>\n            impulseJoints.unmap(handle),\n        );\n        multibodyJoints.forEachJointHandleAttachedToRigidBody(\n            handle,\n            (handle) => multibodyJoints.unmap(handle),\n        );\n\n        // Remove the rigid-body.\n        this.raw.remove(\n            handle,\n            islands.raw,\n            colliders.raw,\n            impulseJoints.raw,\n            multibodyJoints.raw,\n        );\n        this.map.delete(handle);\n    }\n\n    /**\n     * The number of rigid-bodies on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a rigid-body with the given handle?\n     *\n     * @param handle - The rigid-body handle to check.\n     */\n    public contains(handle: RigidBodyHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    public get(handle: RigidBodyHandle): RigidBody | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * Applies the given closure to each rigid-body contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (body: RigidBody) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Applies the given closure to each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEachActiveRigidBody(\n        islands: IslandManager,\n        f: (body: RigidBody) => void,\n    ) {\n        islands.forEachActiveRigidBodyHandle((handle) => {\n            f(this.get(handle));\n        });\n    }\n\n    /**\n     * Gets all rigid-bodies in the list.\n     *\n     * @returns rigid-bodies list.\n     */\n    public getAll(): RigidBody[] {\n        return this.map.getAll();\n    }\n}\n","import {RawIntegrationParameters} from \"../raw\";\n\nexport class IntegrationParameters {\n    raw: RawIntegrationParameters;\n\n    constructor(raw?: RawIntegrationParameters) {\n        this.raw = raw || new RawIntegrationParameters();\n    }\n\n    /**\n     * Free the WASM memory used by these integration parameters.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    /**\n     * The timestep length (default: `1.0 / 60.0`)\n     */\n    get dt(): number {\n        return this.raw.dt;\n    }\n\n    /**\n     * The Error Reduction Parameter in `[0, 1]` is the proportion of\n     * the positional error to be corrected at each time step (default: `0.2`).\n     */\n    get erp(): number {\n        return this.raw.erp;\n    }\n\n    /**\n     * Amount of penetration the engine wont attempt to correct (default: `0.001m`).\n     */\n    get allowedLinearError(): number {\n        return this.raw.allowedLinearError;\n    }\n\n    /**\n     * The maximal distance separating two objects that will generate predictive contacts (default: `0.002`).\n     */\n    get predictionDistance(): number {\n        return this.raw.predictionDistance;\n    }\n\n    /**\n     * Maximum number of iterations performed by the velocity constraints solver (default: `4`).\n     */\n    get maxVelocityIterations(): number {\n        return this.raw.maxVelocityIterations;\n    }\n\n    /**\n     * Maximum number of friction iterations performed by the position-based constraints solver (default: `1`).\n     */\n    get maxVelocityFrictionIterations(): number {\n        return this.raw.maxVelocityFrictionIterations;\n    }\n\n    /**\n     * Maximum number of stabilization iterations performed by the position-based constraints solver (default: `1`).\n     */\n    get maxStabilizationIterations(): number {\n        return this.raw.maxStabilizationIterations;\n    }\n\n    /**\n     * Minimum number of dynamic bodies in each active island (default: `128`).\n     */\n    get minIslandSize(): number {\n        return this.raw.minIslandSize;\n    }\n\n    /**\n     * Maximum number of substeps performed by the  solver (default: `1`).\n     */\n    get maxCcdSubsteps(): number {\n        return this.raw.maxCcdSubsteps;\n    }\n\n    set dt(value: number) {\n        this.raw.dt = value;\n    }\n\n    set erp(value: number) {\n        this.raw.erp = value;\n    }\n\n    set allowedLinearError(value: number) {\n        this.raw.allowedLinearError = value;\n    }\n\n    set predictionDistance(value: number) {\n        this.raw.predictionDistance = value;\n    }\n\n    set maxVelocityIterations(value: number) {\n        this.raw.maxVelocityIterations = value;\n    }\n\n    set maxVelocityFrictionIterations(value: number) {\n        this.raw.maxVelocityFrictionIterations = value;\n    }\n\n    set maxStabilizationIterations(value: number) {\n        this.raw.maxStabilizationIterations = value;\n    }\n\n    set minIslandSize(value: number) {\n        this.raw.minIslandSize = value;\n    }\n\n    set maxCcdSubsteps(value: number) {\n        this.raw.maxCcdSubsteps = value;\n    }\n}\n","import {RawImpulseJointSet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {RigidBodySet} from \"./rigid_body_set\";\nimport {\n    RevoluteImpulseJoint,\n    FixedImpulseJoint,\n    ImpulseJoint,\n    ImpulseJointHandle,\n    JointData,\n    JointType,\n    PrismaticImpulseJoint,\n    // #if DIM3\n    SphericalImpulseJoint,\n    // #endif\n} from \"./impulse_joint\";\nimport {IslandManager} from \"./island_manager\";\nimport {RigidBodyHandle} from \"./rigid_body\";\nimport {Collider, ColliderHandle} from \"../geometry\";\n\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class ImpulseJointSet {\n    raw: RawImpulseJointSet;\n    private map: Coarena<ImpulseJoint>;\n\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawImpulseJointSet) {\n        this.raw = raw || new RawImpulseJointSet();\n        this.map = new Coarena<ImpulseJoint>();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle: ImpulseJointHandle) => {\n                this.map.set(handle, ImpulseJoint.newTyped(raw, null, handle));\n            });\n        }\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodies: RigidBodySet) {\n        this.map.forEach((joint) => joint.finalizeDeserialization(bodies));\n    }\n\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param bodies - The set of rigid-bodies containing the bodies the joint is attached to.\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createJoint(\n        bodies: RigidBodySet,\n        desc: JointData,\n        parent1: RigidBodyHandle,\n        parent2: RigidBodyHandle,\n        wakeUp: boolean,\n    ): ImpulseJoint {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(\n            rawParams,\n            parent1,\n            parent2,\n            wakeUp,\n        );\n        rawParams.free();\n        let joint = ImpulseJoint.newTyped(this.raw, bodies, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wakeUp - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    public remove(handle: ImpulseJointHandle, wakeUp: boolean) {\n        this.raw.remove(handle, wakeUp);\n        this.unmap(handle);\n    }\n\n    /**\n     * Calls the given closure with the integer handle of each impulse joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each impulse joint attached to the rigid-body.\n     */\n    public forEachJointHandleAttachedToRigidBody(\n        handle: RigidBodyHandle,\n        f: (handle: ImpulseJointHandle) => void,\n    ) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    public unmap(handle: ImpulseJointHandle) {\n        this.map.delete(handle);\n    }\n\n    /**\n     * The number of joints on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    public contains(handle: ImpulseJointHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    public get(handle: ImpulseJointHandle): ImpulseJoint | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (joint: ImpulseJoint) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    public getAll(): ImpulseJoint[] {\n        return this.map.getAll();\n    }\n}\n","import {RawImpulseJointSet, RawJointAxis, RawMultibodyJointSet} from \"../raw\";\nimport {\n    FixedImpulseJoint,\n    ImpulseJointHandle,\n    JointType,\n    MotorModel,\n    PrismaticImpulseJoint,\n    RevoluteImpulseJoint,\n} from \"./impulse_joint\";\n\n// #if DIM3\nimport {Quaternion} from \"../math\";\nimport {SphericalImpulseJoint} from \"./impulse_joint\";\n// #endif\n\n/**\n * The integer identifier of a collider added to a `ColliderSet`.\n */\nexport type MultibodyJointHandle = number;\n\nexport class MultibodyJoint {\n    protected rawSet: RawMultibodyJointSet; // The MultibodyJoint won't need to free this.\n    handle: MultibodyJointHandle;\n\n    constructor(rawSet: RawMultibodyJointSet, handle: MultibodyJointHandle) {\n        this.rawSet = rawSet;\n        this.handle = handle;\n    }\n\n    public static newTyped(\n        rawSet: RawMultibodyJointSet,\n        handle: MultibodyJointHandle,\n    ): MultibodyJoint {\n        switch (rawSet.jointType(handle)) {\n            case JointType.Revolute:\n                return new RevoluteMultibodyJoint(rawSet, handle);\n            case JointType.Prismatic:\n                return new PrismaticMultibodyJoint(rawSet, handle);\n            case JointType.Fixed:\n                return new FixedMultibodyJoint(rawSet, handle);\n            // #if DIM3\n            case JointType.Spherical:\n                return new SphericalMultibodyJoint(rawSet, handle);\n            // #endif\n            default:\n                return new MultibodyJoint(rawSet, handle);\n        }\n    }\n\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    public isValid(): boolean {\n        return this.rawSet.contains(this.handle);\n    }\n\n    // /**\n    //  * The unique integer identifier of the first rigid-body this joint it attached to.\n    //  */\n    // public bodyHandle1(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle1(this.handle);\n    // }\n    //\n    // /**\n    //  * The unique integer identifier of the second rigid-body this joint is attached to.\n    //  */\n    // public bodyHandle2(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle2(this.handle);\n    // }\n    //\n    // /**\n    //  * The type of this joint given as a string.\n    //  */\n    // public type(): JointType {\n    //     return this.rawSet.jointType(this.handle);\n    // }\n    //\n    // // #if DIM3\n    // /**\n    //  * The rotation quaternion that aligns this joint's first local axis to the `x` axis.\n    //  */\n    // public frameX1(): Rotation {\n    //     return RotationOps.fromRaw(this.rawSet.jointFrameX1(this.handle));\n    // }\n    //\n    // // #endif\n    //\n    // // #if DIM3\n    // /**\n    //  * The rotation matrix that aligns this joint's second local axis to the `x` axis.\n    //  */\n    // public frameX2(): Rotation {\n    //     return RotationOps.fromRaw(this.rawSet.jointFrameX2(this.handle));\n    // }\n    //\n    // // #endif\n    //\n    // /**\n    //  * The position of the first anchor of this joint.\n    //  *\n    //  * The first anchor gives the position of the points application point on the\n    //  * local frame of the first rigid-body it is attached to.\n    //  */\n    // public anchor1(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    // }\n    //\n    // /**\n    //  * The position of the second anchor of this joint.\n    //  *\n    //  * The second anchor gives the position of the points application point on the\n    //  * local frame of the second rigid-body it is attached to.\n    //  */\n    // public anchor2(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    // }\n\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public setContactsEnabled(enabled: boolean) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    public contactsEnabled(): boolean {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\n\nexport class UnitMultibodyJoint extends MultibodyJoint {\n    /**\n     * The axis left free by this joint.\n     */\n    protected rawAxis?(): RawJointAxis;\n\n    // /**\n    //  * Are the limits enabled for this joint?\n    //  */\n    // public limitsEnabled(): boolean {\n    //     return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());\n    // }\n    //\n    // /**\n    //  * The min limit of this joint.\n    //  */\n    // public limitsMin(): number {\n    //     return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());\n    // }\n    //\n    // /**\n    //  * The max limit of this joint.\n    //  */\n    // public limitsMax(): number {\n    //     return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());\n    // }\n    //\n    // public configureMotorModel(model: MotorModel) {\n    //     this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), model);\n    // }\n    //\n    // public configureMotorVelocity(targetVel: number, factor: number) {\n    //     this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), targetVel, factor);\n    // }\n    //\n    // public configureMotorPosition(targetPos: number, stiffness: number, damping: number) {\n    //     this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), targetPos, stiffness, damping);\n    // }\n    //\n    // public configureMotor(targetPos: number, targetVel: number, stiffness: number, damping: number) {\n    //     this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), targetPos, targetVel, stiffness, damping);\n    // }\n}\n\nexport class FixedMultibodyJoint extends MultibodyJoint {}\n\nexport class PrismaticMultibodyJoint extends UnitMultibodyJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.X;\n    }\n}\n\nexport class RevoluteMultibodyJoint extends UnitMultibodyJoint {\n    public rawAxis(): RawJointAxis {\n        return RawJointAxis.AngX;\n    }\n}\n\n// #if DIM3\nexport class SphericalMultibodyJoint extends MultibodyJoint {\n    /* Unsupported by this alpha release.\n    public configureMotorModel(model: MotorModel) {\n        this.rawSet.jointConfigureMotorModel(this.handle, model);\n    }\n\n    public configureMotorVelocity(targetVel: Vector, factor: number) {\n        this.rawSet.jointConfigureBallMotorVelocity(this.handle, targetVel.x, targetVel.y, targetVel.z, factor);\n    }\n\n    public configureMotorPosition(targetPos: Quaternion, stiffness: number, damping: number) {\n        this.rawSet.jointConfigureBallMotorPosition(this.handle, targetPos.w, targetPos.x, targetPos.y, targetPos.z, stiffness, damping);\n    }\n\n    public configureMotor(targetPos: Quaternion, targetVel: Vector, stiffness: number, damping: number) {\n        this.rawSet.jointConfigureBallMotor(this.handle,\n            targetPos.w, targetPos.x, targetPos.y, targetPos.z,\n            targetVel.x, targetVel.y, targetVel.z,\n            stiffness, damping);\n    }\n     */\n}\n// #endif\n","import {RawMultibodyJointSet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {RigidBodySet} from \"./rigid_body_set\";\nimport {\n    MultibodyJoint,\n    MultibodyJointHandle,\n    RevoluteMultibodyJoint,\n    FixedMultibodyJoint,\n    PrismaticMultibodyJoint,\n    // #if DIM3\n    SphericalMultibodyJoint,\n    // #endif\n} from \"./multibody_joint\";\nimport {ImpulseJointHandle, JointData, JointType} from \"./impulse_joint\";\nimport {IslandManager} from \"./island_manager\";\nimport {ColliderHandle} from \"../geometry\";\nimport {RigidBodyHandle} from \"./rigid_body\";\n\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class MultibodyJointSet {\n    raw: RawMultibodyJointSet;\n    private map: Coarena<MultibodyJoint>;\n\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawMultibodyJointSet) {\n        this.raw = raw || new RawMultibodyJointSet();\n        this.map = new Coarena<MultibodyJoint>();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle: MultibodyJointHandle) => {\n                this.map.set(handle, MultibodyJoint.newTyped(this.raw, handle));\n            });\n        }\n    }\n\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createJoint(\n        desc: JointData,\n        parent1: RigidBodyHandle,\n        parent2: RigidBodyHandle,\n        wakeUp: boolean,\n    ): MultibodyJoint {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(\n            rawParams,\n            parent1,\n            parent2,\n            wakeUp,\n        );\n        rawParams.free();\n        let joint = MultibodyJoint.newTyped(this.raw, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wake_up - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    public remove(handle: MultibodyJointHandle, wake_up: boolean) {\n        this.raw.remove(handle, wake_up);\n        this.map.delete(handle);\n    }\n\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    public unmap(handle: MultibodyJointHandle) {\n        this.map.delete(handle);\n    }\n\n    /**\n     * The number of joints on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    public contains(handle: MultibodyJointHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    public get(handle: MultibodyJointHandle): MultibodyJoint | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (joint: MultibodyJoint) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Calls the given closure with the integer handle of each multibody joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each multibody joint attached to the rigid-body.\n     */\n    public forEachJointHandleAttachedToRigidBody(\n        handle: RigidBodyHandle,\n        f: (handle: MultibodyJointHandle) => void,\n    ) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    public getAll(): MultibodyJoint[] {\n        return this.map.getAll();\n    }\n}\n","import {RawCCDSolver} from \"../raw\";\n\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class CCDSolver {\n    raw: RawCCDSolver;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawCCDSolver) {\n        this.raw = raw || new RawCCDSolver();\n    }\n}\n","import {RawIslandManager} from \"../raw\";\nimport {RigidBodyHandle} from \"./rigid_body\";\n\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class IslandManager {\n    raw: RawIslandManager;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawIslandManager) {\n        this.raw = raw || new RawIslandManager();\n    }\n\n    /**\n     * Applies the given closure to the handle of each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEachActiveRigidBodyHandle(f: (handle: RigidBodyHandle) => void) {\n        this.raw.forEachActiveRigidBodyHandle(f);\n    }\n}\n","import {RawBroadPhase} from \"../raw\";\n\n/**\n * The broad-phase used for coarse collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `broadPhase.free()`\n * once you are done using it.\n */\nexport class BroadPhase {\n    raw: RawBroadPhase;\n\n    /**\n     * Release the WASM memory occupied by this broad-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawBroadPhase) {\n        this.raw = raw || new RawBroadPhase();\n    }\n}\n","import {RawNarrowPhase, RawContactManifold} from \"../raw\";\nimport {ColliderHandle} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\n\n/**\n * The narrow-phase used for precise collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `narrowPhase.free()`\n * once you are done using it.\n */\nexport class NarrowPhase {\n    raw: RawNarrowPhase;\n    tempManifold: TempContactManifold;\n\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawNarrowPhase) {\n        this.raw = raw || new RawNarrowPhase();\n        this.tempManifold = new TempContactManifold(null);\n    }\n\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    public contactsWith(\n        collider1: ColliderHandle,\n        f: (collider2: ColliderHandle) => void,\n    ) {\n        this.raw.contacts_with(collider1, f);\n    }\n\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    public intersectionsWith(\n        collider1: ColliderHandle,\n        f: (collider2: ColliderHandle) => void,\n    ) {\n        this.raw.intersections_with(collider1, f);\n    }\n\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    public contactPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n        f: (manifold: TempContactManifold, flipped: boolean) => void,\n    ) {\n        const rawPair = this.raw.contact_pair(collider1, collider2);\n\n        if (!!rawPair) {\n            const flipped = rawPair.collider1() != collider1;\n\n            let i;\n            for (i = 0; i < rawPair.numContactManifolds(); ++i) {\n                this.tempManifold.raw = rawPair.contactManifold(i);\n                if (!!this.tempManifold.raw) {\n                    f(this.tempManifold, flipped);\n                }\n\n                // SAFETY: The RawContactManifold stores a raw pointer that will be invalidated\n                //         at the next timestep. So we must be sure to free the pair here\n                //         to avoid unsoundness in the Rust code.\n                this.tempManifold.free();\n            }\n            rawPair.free();\n        }\n    }\n\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1  The first collider involved in the intersection.\n     * @param collider2  The second collider involved in the intersection.\n     */\n    public intersectionPair(\n        collider1: ColliderHandle,\n        collider2: ColliderHandle,\n    ): boolean {\n        return this.raw.intersection_pair(collider1, collider2);\n    }\n}\n\nexport class TempContactManifold {\n    raw: RawContactManifold;\n\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw: RawContactManifold) {\n        this.raw = raw;\n    }\n\n    public normal(): Vector {\n        return VectorOps.fromRaw(this.raw.normal());\n    }\n\n    public localNormal1(): Vector {\n        return VectorOps.fromRaw(this.raw.local_n1());\n    }\n\n    public localNormal2(): Vector {\n        return VectorOps.fromRaw(this.raw.local_n2());\n    }\n\n    public subshape1(): number {\n        return this.raw.subshape1();\n    }\n\n    public subshape2(): number {\n        return this.raw.subshape2();\n    }\n\n    public numContacts(): number {\n        return this.raw.num_contacts();\n    }\n\n    public localContactPoint1(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.contact_local_p1(i));\n    }\n\n    public localContactPoint2(i: number): Vector | null {\n        return VectorOps.fromRaw(this.raw.contact_local_p2(i));\n    }\n\n    public contactDist(i: number): number {\n        return this.raw.contact_dist(i);\n    }\n\n    public contactFid1(i: number): number {\n        return this.raw.contact_fid1(i);\n    }\n\n    public contactFid2(i: number): number {\n        return this.raw.contact_fid2(i);\n    }\n\n    public contactImpulse(i: number): number {\n        return this.raw.contact_impulse(i);\n    }\n\n\n    // #if DIM3\n    public contactTangentImpulseX(i: number): number {\n        return this.raw.contact_tangent_impulse_x(i);\n    }\n\n    public contactTangentImpulseY(i: number): number {\n        return this.raw.contact_tangent_impulse_y(i);\n    }\n    // #endif\n\n    public numSolverContacts(): number {\n        return this.raw.num_solver_contacts();\n    }\n\n    public solverContactPoint(i: number): Vector {\n        return VectorOps.fromRaw(this.raw.solver_contact_point(i));\n    }\n\n    public solverContactDist(i: number): number {\n        return this.raw.solver_contact_dist(i);\n    }\n\n    public solverContactFriction(i: number): number {\n        return this.raw.solver_contact_friction(i);\n    }\n\n    public solverContactRestitution(i: number): number {\n        return this.raw.solver_contact_restitution(i);\n    }\n\n    public solverContactTangentVelocity(i: number): Vector {\n        return VectorOps.fromRaw(this.raw.solver_contact_tangent_velocity(i));\n    }\n}\n","import {Vector, VectorOps} from \"../math\";\nimport {RawShapeContact} from \"../raw\";\n\n/**\n * The contact info between two shapes.\n */\nexport class ShapeContact {\n    /**\n     * Distance between the two contact points.\n     * If this is negative, this contact represents a penetration.\n     */\n    distance: number;\n\n    /**\n     * Position of the contact on the first shape.\n     */\n    point1: Vector;\n\n    /**\n     * Position of the contact on the second shape.\n     */\n    point2: Vector;\n\n    /**\n     * Contact normal, pointing towards the exterior of the first shape.\n     */\n    normal1: Vector;\n\n    /**\n     * Contact normal, pointing towards the exterior of the second shape.\n     * If these contact data are expressed in world-space, this normal is equal to -normal1.\n     */\n    normal2: Vector;\n\n    constructor(\n        dist: number,\n        point1: Vector,\n        point2: Vector,\n        normal1: Vector,\n        normal2: Vector,\n    ) {\n        this.distance = dist;\n        this.point1 = point1;\n        this.point2 = point2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n\n    public static fromRaw(raw: RawShapeContact): ShapeContact {\n        if (!raw) return null;\n\n        const result = new ShapeContact(\n            raw.distance(),\n            VectorOps.fromRaw(raw.point1()),\n            VectorOps.fromRaw(raw.point2()),\n            VectorOps.fromRaw(raw.normal1()),\n            VectorOps.fromRaw(raw.normal2()),\n        );\n        raw.free();\n        return result;\n    }\n}\n","import {Collider, ColliderHandle} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\nimport {RawPointColliderProjection, RawPointProjection} from \"../raw\";\nimport {FeatureType} from \"./feature\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * The projection of a point on a collider.\n */\nexport class PointProjection {\n    /**\n     * The projection of the point on the collider.\n     */\n    point: Vector;\n    /**\n     * Is the point inside of the collider?\n     */\n    isInside: boolean;\n\n    constructor(point: Vector, isInside: boolean) {\n        this.point = point;\n        this.isInside = isInside;\n    }\n\n    public static fromRaw(raw: RawPointProjection): PointProjection {\n        if (!raw) return null;\n\n        const result = new PointProjection(\n            VectorOps.fromRaw(raw.point()),\n            raw.isInside(),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The projection of a point on a collider (includes the collider handle).\n */\nexport class PointColliderProjection {\n    /**\n     * The collider hit by the ray.\n     */\n    collider: Collider;\n    /**\n     * The projection of the point on the collider.\n     */\n    point: Vector;\n    /**\n     * Is the point inside of the collider?\n     */\n    isInside: boolean;\n\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    featureType = FeatureType.Unknown;\n\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    featureId: number | undefined = undefined;\n\n    constructor(\n        collider: Collider,\n        point: Vector,\n        isInside: boolean,\n        featureType?: FeatureType,\n        featureId?: number,\n    ) {\n        this.collider = collider;\n        this.point = point;\n        this.isInside = isInside;\n        if (featureId !== undefined) this.featureId = featureId;\n        if (featureType !== undefined) this.featureType = featureType;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawPointColliderProjection,\n    ): PointColliderProjection {\n        if (!raw) return null;\n\n        const result = new PointColliderProjection(\n            colliderSet.get(raw.colliderHandle()),\n            VectorOps.fromRaw(raw.point()),\n            raw.isInside(),\n            raw.featureType(),\n            raw.featureId(),\n        );\n        raw.free();\n        return result;\n    }\n}\n","import {Vector, VectorOps} from \"../math\";\nimport {\n    RawRayColliderIntersection,\n    RawRayColliderToi,\n    RawRayIntersection,\n} from \"../raw\";\nimport {Collider} from \"./collider\";\nimport {FeatureType} from \"./feature\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * A ray. This is a directed half-line.\n */\nexport class Ray {\n    /**\n     * The starting point of the ray.\n     */\n    public origin: Vector;\n    /**\n     * The direction of propagation of the ray.\n     */\n    public dir: Vector;\n\n    /**\n     * Builds a ray from its origin and direction.\n     *\n     * @param origin - The ray's starting point.\n     * @param dir - The ray's direction of propagation.\n     */\n    constructor(origin: Vector, dir: Vector) {\n        this.origin = origin;\n        this.dir = dir;\n    }\n\n    public pointAt(t: number): Vector {\n        return {\n            x: this.origin.x + this.dir.x * t,\n            y: this.origin.y + this.dir.y * t,\n            // #if DIM3\n            z: this.origin.z + this.dir.z * t,\n            // #endif\n        };\n    }\n}\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class RayIntersection {\n    /**\n     * The time-of-impact of the ray with the collider.\n     *\n     * The hit point is obtained from the ray's origin and direction: `origin + dir * toi`.\n     */\n    toi: number;\n    /**\n     * The normal of the collider at the hit point.\n     */\n    normal: Vector;\n\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    featureType = FeatureType.Unknown;\n\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    featureId: number | undefined = undefined;\n\n    constructor(\n        toi: number,\n        normal: Vector,\n        featureType?: FeatureType,\n        featureId?: number,\n    ) {\n        this.toi = toi;\n        this.normal = normal;\n        if (featureId !== undefined) this.featureId = featureId;\n        if (featureType !== undefined) this.featureType = featureType;\n    }\n\n    public static fromRaw(raw: RawRayIntersection): RayIntersection {\n        if (!raw) return null;\n\n        const result = new RayIntersection(\n            raw.toi(),\n            VectorOps.fromRaw(raw.normal()),\n            raw.featureType(),\n            raw.featureId(),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The intersection between a ray and a collider (includes the collider handle).\n */\nexport class RayColliderIntersection {\n    /**\n     * The collider hit by the ray.\n     */\n    collider: Collider;\n    /**\n     * The time-of-impact of the ray with the collider.\n     *\n     * The hit point is obtained from the ray's origin and direction: `origin + dir * toi`.\n     */\n    toi: number;\n    /**\n     * The normal of the collider at the hit point.\n     */\n    normal: Vector;\n\n    /**\n     * The type of the geometric feature the point was projected on.\n     */\n    featureType = FeatureType.Unknown;\n\n    /**\n     * The id of the geometric feature the point was projected on.\n     */\n    featureId: number | undefined = undefined;\n\n    constructor(\n        collider: Collider,\n        toi: number,\n        normal: Vector,\n        featureType?: FeatureType,\n        featureId?: number,\n    ) {\n        this.collider = collider;\n        this.toi = toi;\n        this.normal = normal;\n        if (featureId !== undefined) this.featureId = featureId;\n        if (featureType !== undefined) this.featureType = featureType;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawRayColliderIntersection,\n    ): RayColliderIntersection {\n        if (!raw) return null;\n\n        const result = new RayColliderIntersection(\n            colliderSet.get(raw.colliderHandle()),\n            raw.toi(),\n            VectorOps.fromRaw(raw.normal()),\n            raw.featureType(),\n            raw.featureId(),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The time of impact between a ray and a collider.\n */\nexport class RayColliderToi {\n    /**\n     * The handle of the collider hit by the ray.\n     */\n    collider: Collider;\n    /**\n     * The time-of-impact of the ray with the collider.\n     *\n     * The hit point is obtained from the ray's origin and direction: `origin + dir * toi`.\n     */\n    toi: number;\n\n    constructor(collider: Collider, toi: number) {\n        this.collider = collider;\n        this.toi = toi;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawRayColliderToi,\n    ): RayColliderToi {\n        if (!raw) return null;\n\n        const result = new RayColliderToi(\n            colliderSet.get(raw.colliderHandle()),\n            raw.toi(),\n        );\n        raw.free();\n        return result;\n    }\n}\n","import {Collider} from \"./collider\";\nimport {Vector, VectorOps} from \"../math\";\nimport {RawShapeTOI, RawShapeColliderTOI} from \"../raw\";\nimport {ColliderSet} from \"./collider_set\";\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class ShapeTOI {\n    /**\n     * The time of impact of the two shapes.\n     */\n    toi: number;\n    /**\n     * The local-space contact point on the first shape, at\n     * the time of impact.\n     */\n    witness1: Vector;\n    /**\n     * The local-space contact point on the second shape, at\n     * the time of impact.\n     */\n    witness2: Vector;\n    /**\n     * The local-space normal on the first shape, at\n     * the time of impact.\n     */\n    normal1: Vector;\n    /**\n     * The local-space normal on the second shape, at\n     * the time of impact.\n     */\n    normal2: Vector;\n\n    constructor(\n        toi: number,\n        witness1: Vector,\n        witness2: Vector,\n        normal1: Vector,\n        normal2: Vector,\n    ) {\n        this.toi = toi;\n        this.witness1 = witness1;\n        this.witness2 = witness2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawShapeTOI,\n    ): ShapeTOI {\n        if (!raw) return null;\n\n        const result = new ShapeTOI(\n            raw.toi(),\n            VectorOps.fromRaw(raw.witness1()),\n            VectorOps.fromRaw(raw.witness2()),\n            VectorOps.fromRaw(raw.normal1()),\n            VectorOps.fromRaw(raw.normal2()),\n        );\n        raw.free();\n        return result;\n    }\n}\n\n/**\n * The intersection between a ray and a collider.\n */\nexport class ShapeColliderTOI extends ShapeTOI {\n    /**\n     * The handle of the collider hit by the ray.\n     */\n    collider: Collider;\n\n    constructor(\n        collider: Collider,\n        toi: number,\n        witness1: Vector,\n        witness2: Vector,\n        normal1: Vector,\n        normal2: Vector,\n    ) {\n        super(toi, witness1, witness2, normal1, normal2);\n        this.collider = collider;\n    }\n\n    public static fromRaw(\n        colliderSet: ColliderSet,\n        raw: RawShapeColliderTOI,\n    ): ShapeColliderTOI {\n        if (!raw) return null;\n\n        const result = new ShapeColliderTOI(\n            colliderSet.get(raw.colliderHandle()),\n            raw.toi(),\n            VectorOps.fromRaw(raw.witness1()),\n            VectorOps.fromRaw(raw.witness2()),\n            VectorOps.fromRaw(raw.normal1()),\n            VectorOps.fromRaw(raw.normal2()),\n        );\n        raw.free();\n        return result;\n    }\n}\n","import {RawColliderSet} from \"../raw\";\nimport {Coarena} from \"../coarena\";\nimport {RotationOps, VectorOps} from \"../math\";\nimport {Collider, ColliderDesc, ColliderHandle} from \"./collider\";\nimport {ImpulseJointHandle, IslandManager, RigidBodyHandle} from \"../dynamics\";\nimport {RigidBodySet} from \"../dynamics\";\n\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `colliderSet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class ColliderSet {\n    raw: RawColliderSet;\n    private map: Coarena<Collider>;\n\n    /**\n     * Release the WASM memory occupied by this collider set.\n     */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n\n    constructor(raw?: RawColliderSet) {\n        this.raw = raw || new RawColliderSet();\n        this.map = new Coarena<Collider>();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachColliderHandle((handle: ColliderHandle) => {\n                this.map.set(handle, new Collider(this, handle, null));\n            });\n        }\n    }\n\n    /** @internal */\n    public castClosure<Res>(\n        f?: (collider: Collider) => Res,\n    ): (handle: ColliderHandle) => Res | undefined {\n        return (handle) => {\n            if (!!f) {\n                return f(this.get(handle));\n            } else {\n                return undefined;\n            }\n        };\n    }\n\n    /** @internal */\n    public finalizeDeserialization(bodies: RigidBodySet) {\n        this.map.forEach((collider) =>\n            collider.finalizeDeserialization(bodies),\n        );\n    }\n\n    /**\n     * Creates a new collider and return its integer handle.\n     *\n     * @param bodies - The set of bodies where the collider's parent can be found.\n     * @param desc - The collider's description.\n     * @param parentHandle - The integer handle of the rigid-body this collider is attached to.\n     */\n    public createCollider(\n        bodies: RigidBodySet,\n        desc: ColliderDesc,\n        parentHandle: RigidBodyHandle,\n    ): Collider {\n        let hasParent = parentHandle != undefined && parentHandle != null;\n\n        if (hasParent && isNaN(parentHandle))\n            throw Error(\n                \"Cannot create a collider with a parent rigid-body handle that is not a number.\",\n            );\n\n        let rawShape = desc.shape.intoRaw();\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n\n        // #if DIM3\n        let rawPrincipalInertia = VectorOps.intoRaw(\n            desc.principalAngularInertia,\n        );\n        let rawInertiaFrame = RotationOps.intoRaw(\n            desc.angularInertiaLocalFrame,\n        );\n        // #endif\n\n        let handle = this.raw.createCollider(\n            desc.enabled,\n            rawShape,\n            rawTra,\n            rawRot,\n            desc.massPropsMode,\n            desc.mass,\n            rawCom,\n            // #if DIM3\n            rawPrincipalInertia,\n            rawInertiaFrame,\n            // #endif\n            desc.density,\n            desc.friction,\n            desc.restitution,\n            desc.frictionCombineRule,\n            desc.restitutionCombineRule,\n            desc.isSensor,\n            desc.collisionGroups,\n            desc.solverGroups,\n            desc.activeCollisionTypes,\n            desc.activeHooks,\n            desc.activeEvents,\n            desc.contactForceEventThreshold,\n            hasParent,\n            hasParent ? parentHandle : 0,\n            bodies.raw,\n        );\n\n        rawShape.free();\n        rawTra.free();\n        rawRot.free();\n        rawCom.free();\n\n        // #if DIM3\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n        // #endif\n\n        let parent = hasParent ? bodies.get(parentHandle) : null;\n        let collider = new Collider(this, handle, parent, desc.shape);\n        this.map.set(handle, collider);\n        return collider;\n    }\n\n    /**\n     * Remove a collider from this set.\n     *\n     * @param handle - The integer handle of the collider to remove.\n     * @param bodies - The set of rigid-body containing the rigid-body the collider is attached to.\n     * @param wakeUp - If `true`, the rigid-body the removed collider is attached to will be woken-up automatically.\n     */\n    public remove(\n        handle: ColliderHandle,\n        islands: IslandManager,\n        bodies: RigidBodySet,\n        wakeUp: boolean,\n    ) {\n        this.raw.remove(handle, islands.raw, bodies.raw, wakeUp);\n        this.unmap(handle);\n    }\n\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    public unmap(handle: ImpulseJointHandle) {\n        this.map.delete(handle);\n    }\n\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    public get(handle: ColliderHandle): Collider | null {\n        return this.map.get(handle);\n    }\n\n    /**\n     * The number of colliders on this set.\n     */\n    public len(): number {\n        return this.map.len();\n    }\n\n    /**\n     * Does this set contain a collider with the given handle?\n     *\n     * @param handle - The collider handle to check.\n     */\n    public contains(handle: ColliderHandle): boolean {\n        return this.get(handle) != null;\n    }\n\n    /**\n     * Applies the given closure to each collider contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    public forEach(f: (collider: Collider) => void) {\n        this.map.forEach(f);\n    }\n\n    /**\n     * Gets all colliders in the list.\n     *\n     * @returns collider list.\n     */\n    public getAll(): Collider[] {\n        return this.map.getAll();\n    }\n}\n","import {RawPhysicsPipeline} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    IntegrationParameters,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBodyHandle,\n    RigidBodySet,\n    CCDSolver,\n    IslandManager,\n} from \"../dynamics\";\nimport {\n    BroadPhase,\n    ColliderHandle,\n    ColliderSet,\n    NarrowPhase,\n} from \"../geometry\";\nimport {EventQueue} from \"./event_queue\";\nimport {PhysicsHooks} from \"./physics_hooks\";\n\nexport class PhysicsPipeline {\n    raw: RawPhysicsPipeline;\n\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawPhysicsPipeline) {\n        this.raw = raw || new RawPhysicsPipeline();\n    }\n\n    public step(\n        gravity: Vector,\n        integrationParameters: IntegrationParameters,\n        islands: IslandManager,\n        broadPhase: BroadPhase,\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        impulseJoints: ImpulseJointSet,\n        multibodyJoints: MultibodyJointSet,\n        ccdSolver: CCDSolver,\n        eventQueue?: EventQueue,\n        hooks?: PhysicsHooks,\n    ) {\n        let rawG = VectorOps.intoRaw(gravity);\n\n        if (!!eventQueue) {\n            this.raw.stepWithEvents(\n                rawG,\n                integrationParameters.raw,\n                islands.raw,\n                broadPhase.raw,\n                narrowPhase.raw,\n                bodies.raw,\n                colliders.raw,\n                impulseJoints.raw,\n                multibodyJoints.raw,\n                ccdSolver.raw,\n                eventQueue.raw,\n                hooks,\n                !!hooks ? hooks.filterContactPair : null,\n                !!hooks ? hooks.filterIntersectionPair : null,\n            );\n        } else {\n            this.raw.step(\n                rawG,\n                integrationParameters.raw,\n                islands.raw,\n                broadPhase.raw,\n                narrowPhase.raw,\n                bodies.raw,\n                colliders.raw,\n                impulseJoints.raw,\n                multibodyJoints.raw,\n                ccdSolver.raw,\n            );\n        }\n\n        rawG.free();\n    }\n}\n","import {RawSerializationPipeline} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    IntegrationParameters,\n    IslandManager,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {BroadPhase, ColliderSet, NarrowPhase} from \"../geometry\";\nimport {World} from \"./world\";\n\n/**\n * A pipeline for serializing the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class SerializationPipeline {\n    raw: RawSerializationPipeline;\n\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n\n    constructor(raw?: RawSerializationPipeline) {\n        this.raw = raw || new RawSerializationPipeline();\n    }\n\n    /**\n     * Serialize a complete physics state into a single byte array.\n     * @param gravity - The current gravity affecting the simulation.\n     * @param integrationParameters - The integration parameters of the simulation.\n     * @param broadPhase - The broad-phase of the simulation.\n     * @param narrowPhase - The narrow-phase of the simulation.\n     * @param bodies - The rigid-bodies taking part into the simulation.\n     * @param colliders - The colliders taking part into the simulation.\n     * @param impulseJoints - The impulse joints taking part into the simulation.\n     * @param multibodyJoints - The multibody joints taking part into the simulation.\n     */\n    public serializeAll(\n        gravity: Vector,\n        integrationParameters: IntegrationParameters,\n        islands: IslandManager,\n        broadPhase: BroadPhase,\n        narrowPhase: NarrowPhase,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        impulseJoints: ImpulseJointSet,\n        multibodyJoints: MultibodyJointSet,\n    ): Uint8Array {\n        let rawGra = VectorOps.intoRaw(gravity);\n\n        const res = this.raw.serializeAll(\n            rawGra,\n            integrationParameters.raw,\n            islands.raw,\n            broadPhase.raw,\n            narrowPhase.raw,\n            bodies.raw,\n            colliders.raw,\n            impulseJoints.raw,\n            multibodyJoints.raw,\n        );\n        rawGra.free();\n\n        return res;\n    }\n\n    /**\n     * Deserialize the complete physics state from a single byte array.\n     *\n     * @param data - The byte array to deserialize.\n     */\n    public deserializeAll(data: Uint8Array): World {\n        return World.fromRaw(this.raw.deserializeAll(data));\n    }\n}\n","import {RawDebugRenderPipeline} from \"../raw\";\nimport {Vector, VectorOps} from \"../math\";\nimport {\n    IntegrationParameters,\n    IslandManager,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {BroadPhase, ColliderSet, NarrowPhase} from \"../geometry\";\n\n/**\n * The vertex and color buffers for debug-redering the physics scene.\n */\nexport class DebugRenderBuffers {\n    /**\n     * The lines to render. This is a flat array containing all the lines\n     * to render. Each line is described as two consecutive point. Each\n     * point is described as two (in 2D) or three (in 3D) consecutive\n     * floats. For example, in 2D, the array: `[1, 2, 3, 4, 5, 6, 7, 8]`\n     * describes the two segments `[[1, 2], [3, 4]]` and `[[5, 6], [7, 8]]`.\n     */\n    public vertices: Float32Array;\n    /**\n     * The color buffer. There is one color per vertex, and each color\n     * has four consecutive components (in RGBA format).\n     */\n    public colors: Float32Array;\n\n    constructor(vertices: Float32Array, colors: Float32Array) {\n        this.vertices = vertices;\n        this.colors = colors;\n    }\n}\n\n/**\n * A pipeline for rendering the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `debugRenderPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class DebugRenderPipeline {\n    raw: RawDebugRenderPipeline;\n    public vertices: Float32Array;\n    public colors: Float32Array;\n\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        this.vertices = undefined;\n        this.colors = undefined;\n    }\n\n    constructor(raw?: RawDebugRenderPipeline) {\n        this.raw = raw || new RawDebugRenderPipeline();\n    }\n\n    public render(\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        impulse_joints: ImpulseJointSet,\n        multibody_joints: MultibodyJointSet,\n        narrow_phase: NarrowPhase,\n    ) {\n        this.raw.render(\n            bodies.raw,\n            colliders.raw,\n            impulse_joints.raw,\n            multibody_joints.raw,\n            narrow_phase.raw,\n        );\n        this.vertices = this.raw.vertices();\n        this.colors = this.raw.colors();\n    }\n}\n","import {RawKinematicCharacterController, RawCharacterCollision} from \"../raw\";\nimport {Rotation, Vector, VectorOps} from \"../math\";\nimport {Collider, ColliderSet, InteractionGroups, Shape} from \"../geometry\";\nimport {QueryFilterFlags, QueryPipeline, World} from \"../pipeline\";\nimport {IntegrationParameters, RigidBody, RigidBodySet} from \"../dynamics\";\n\n/**\n * A collision between the character and an obstacle hit on its path.\n */\nexport class CharacterCollision {\n    /** The collider involved in the collision. Null if the collider no longer exists in the physics world. */\n    public collider: Collider | null;\n    /** The translation applied to the character before this collision took place. */\n    public translationApplied: Vector;\n    /** The translation the character would move after this collision if there is no other obstacles. */\n    public translationRemaining: Vector;\n    /** The time-of-impact between the character and the obstacles. */\n    public toi: number;\n    /** The world-space contact point on the collider when the collision happens. */\n    public witness1: Vector;\n    /** The local-space contact point on the character when the collision happens. */\n    public witness2: Vector;\n    /** The world-space outward contact normal on the collider when the collision happens. */\n    public normal1: Vector;\n    /** The local-space outward contact normal on the character when the collision happens. */\n    public normal2: Vector;\n}\n\n/**\n * A character controller for controlling kinematic bodies and parentless colliders by hitting\n * and sliding against obstacles.\n */\nexport class KinematicCharacterController {\n    private raw: RawKinematicCharacterController;\n    private rawCharacterCollision: RawCharacterCollision;\n\n    private params: IntegrationParameters;\n    private bodies: RigidBodySet;\n    private colliders: ColliderSet;\n    private queries: QueryPipeline;\n    private _applyImpulsesToDynamicBodies: boolean;\n    private _characterMass: number | null;\n\n    constructor(\n        offset: number,\n        params: IntegrationParameters,\n        bodies: RigidBodySet,\n        colliders: ColliderSet,\n        queries: QueryPipeline,\n    ) {\n        this.params = params;\n        this.bodies = bodies;\n        this.colliders = colliders;\n        this.queries = queries;\n        this.raw = new RawKinematicCharacterController(offset);\n        this.rawCharacterCollision = new RawCharacterCollision();\n        this._applyImpulsesToDynamicBodies = false;\n        this._characterMass = null;\n    }\n\n    /** @internal */\n    public free() {\n        if (!!this.raw) {\n            this.raw.free();\n            this.rawCharacterCollision.free();\n        }\n\n        this.raw = undefined;\n        this.rawCharacterCollision = undefined;\n    }\n\n    /**\n     * The direction that goes \"up\". Used to determine where the floor is, and the floors angle.\n     */\n    public up(): Vector {\n        return this.raw.up();\n    }\n\n    /**\n     * Sets the direction that goes \"up\". Used to determine where the floor is, and the floors angle.\n     */\n    public setUp(vector: Vector) {\n        let rawVect = VectorOps.intoRaw(vector);\n        return this.raw.setUp(rawVect);\n        rawVect.free();\n    }\n\n    public applyImpulsesToDynamicBodies(): boolean {\n        return this._applyImpulsesToDynamicBodies;\n    }\n\n    public setApplyImpulsesToDynamicBodies(enabled: boolean) {\n        this._applyImpulsesToDynamicBodies = enabled;\n    }\n\n    /**\n     * Returns the custom value of the character mass, if it was set by `this.setCharacterMass`.\n     */\n    public characterMass(): number | null {\n        return this._characterMass;\n    }\n\n    /**\n     * Set the mass of the character to be used for impulse resolution if `self.applyImpulsesToDynamicBodies`\n     * is set to `true`.\n     *\n     * If no character mass is set explicitly (or if it is set to `null`) it is automatically assumed to be equal\n     * to the mass of the rigid-body the character collider is attached to; or equal to 0 if the character collider\n     * isnt attached to any rigid-body.\n     *\n     * @param mass - The mass to set.\n     */\n    public setCharacterMass(mass: number | null) {\n        this._characterMass = mass;\n    }\n\n    /**\n     * A small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldnt be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    public offset(): number {\n        return this.raw.offset();\n    }\n\n    /**\n     * Sets a small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldnt be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    public setOffset(value: number) {\n        this.raw.setOffset(value);\n    }\n\n    /**\n     * Is sliding against obstacles enabled?\n     */\n    public slideEnabled(): boolean {\n        return this.raw.slideEnabled();\n    }\n\n    /**\n     * Enable or disable sliding against obstacles.\n     */\n    public setSlideEnabled(enabled: boolean) {\n        this.raw.setSlideEnabled(enabled);\n    }\n\n    /**\n     * The maximum step height a character can automatically step over.\n     */\n    public autostepMaxHeight(): number | null {\n        return this.raw.autostepMaxHeight();\n    }\n\n    /**\n     * The minimum width of free space that must be available after stepping on a stair.\n     */\n    public autostepMinWidth(): number | null {\n        return this.raw.autostepMinWidth();\n    }\n\n    /**\n     * Can the character automatically step over dynamic bodies too?\n     */\n    public autostepIncludesDynamicBodies(): boolean | null {\n        return this.raw.autostepIncludesDynamicBodies();\n    }\n\n    /**\n     * Is automatically stepping over small objects enabled?\n     */\n    public autostepEnabled(): boolean {\n        return this.raw.autostepEnabled();\n    }\n\n    /**\n     * Enabled automatically stepping over small objects.\n     *\n     * @param maxHeight - The maximum step height a character can automatically step over.\n     * @param minWidth - The minimum width of free space that must be available after stepping on a stair.\n     * @param includeDynamicBodies - Can the character automatically step over dynamic bodies too?\n     */\n    public enableAutostep(\n        maxHeight: number,\n        minWidth: number,\n        includeDynamicBodies: boolean,\n    ) {\n        this.raw.enableAutostep(maxHeight, minWidth, includeDynamicBodies);\n    }\n\n    /**\n     * Disable automatically stepping over small objects.\n     */\n    public disableAutostep() {\n        return this.raw.disableAutostep();\n    }\n\n    /**\n     * The maximum angle (radians) between the floors normal and the `up` vector that the\n     * character is able to climb.\n     */\n    public maxSlopeClimbAngle(): number {\n        return this.raw.maxSlopeClimbAngle();\n    }\n\n    /**\n     * Sets the maximum angle (radians) between the floors normal and the `up` vector that the\n     * character is able to climb.\n     */\n    public setMaxSlopeClimbAngle(angle: number) {\n        this.raw.setMaxSlopeClimbAngle(angle);\n    }\n\n    /**\n     * The minimum angle (radians) between the floors normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    public minSlopeSlideAngle(): number {\n        return this.raw.minSlopeSlideAngle();\n    }\n\n    /**\n     * Sets the minimum angle (radians) between the floors normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    public setMinSlopeSlideAngle(angle: number) {\n        this.raw.setMinSlopeSlideAngle(angle);\n    }\n\n    /**\n     * If snap-to-ground is enabled, should the character be automatically snapped to the ground if\n     * the distance between the ground and its feet are smaller than the specified threshold?\n     */\n    public snapToGroundDistance(): number | null {\n        return this.raw.snapToGroundDistance();\n    }\n\n    /**\n     * Enables automatically snapping the character to the ground if the distance between\n     * the ground and its feet are smaller than the specified threshold.\n     */\n    public enableSnapToGround(distance: number) {\n        this.raw.enableSnapToGround(distance);\n    }\n\n    /**\n     * Disables automatically snapping the character to the ground.\n     */\n    public disableSnapToGround() {\n        this.raw.disableSnapToGround();\n    }\n\n    /**\n     * Is automatically snapping the character to the ground enabled?\n     */\n    public snapToGroundEnabled(): boolean {\n        return this.raw.snapToGroundEnabled();\n    }\n\n    /**\n     * Computes the movement the given collider is able to execute after hitting and sliding on obstacles.\n     *\n     * @param collider - The collider to move.\n     * @param desiredTranslation - The desired collider movement.\n     * @param filterFlags - Flags for excluding whole subsets of colliders from the obstacles taken into account.\n     * @param filterGroups - Groups for excluding colliders with incompatible collision groups from the obstacles\n     *                       taken into account.\n     * @param filterPredicate - Any collider for which this closure returns `false` will be excluded from the\n     *                          obstacles taken into account.\n     */\n    public computeColliderMovement(\n        collider: Collider,\n        desiredTranslation: Vector,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        let rawTranslation = VectorOps.intoRaw(desiredTranslation);\n        this.raw.computeColliderMovement(\n            this.params.dt,\n            this.bodies.raw,\n            this.colliders.raw,\n            this.queries.raw,\n            collider.handle,\n            rawTranslation,\n            this._applyImpulsesToDynamicBodies,\n            this._characterMass,\n            filterFlags,\n            filterGroups,\n            this.colliders.castClosure(filterPredicate),\n        );\n        rawTranslation.free();\n    }\n\n    /**\n     * The movement computed by the last call to `this.computeColliderMovement`.\n     */\n    public computedMovement(): Vector {\n        return VectorOps.fromRaw(this.raw.computedMovement());\n    }\n\n    /**\n     * The result of ground detection computed by the last call to `this.computeColliderMovement`.\n     */\n    public computedGrounded(): boolean {\n        return this.raw.computedGrounded();\n    }\n\n    /**\n     * The number of collisions against obstacles detected along the path of the last call\n     * to `this.computeColliderMovement`.\n     */\n    public numComputedCollisions(): number {\n        return this.raw.numComputedCollisions();\n    }\n\n    /**\n     * Returns the collision against one of the obstacles detected along the path of the last\n     * call to `this.computeColliderMovement`.\n     *\n     * @param i - The i-th collision will be returned.\n     * @param out - If this argument is set, it will be filled with the collision information.\n     */\n    public computedCollision(\n        i: number,\n        out?: CharacterCollision,\n    ): CharacterCollision | null {\n        if (!this.raw.computedCollision(i, this.rawCharacterCollision)) {\n            return null;\n        } else {\n            let c = this.rawCharacterCollision;\n            out = out ?? new CharacterCollision();\n            out.translationApplied = VectorOps.fromRaw(c.translationApplied());\n            out.translationRemaining = VectorOps.fromRaw(\n                c.translationRemaining(),\n            );\n            out.toi = c.toi();\n            out.witness1 = VectorOps.fromRaw(c.worldWitness1());\n            out.witness2 = VectorOps.fromRaw(c.worldWitness2());\n            out.normal1 = VectorOps.fromRaw(c.worldNormal1());\n            out.normal2 = VectorOps.fromRaw(c.worldNormal2());\n            out.collider = this.colliders.get(c.handle());\n            return out;\n        }\n    }\n}\n","import {\n    RawBroadPhase,\n    RawCCDSolver,\n    RawColliderSet,\n    RawDeserializedWorld,\n    RawIntegrationParameters,\n    RawIslandManager,\n    RawImpulseJointSet,\n    RawMultibodyJointSet,\n    RawNarrowPhase,\n    RawPhysicsPipeline,\n    RawQueryPipeline,\n    RawRigidBodySet,\n    RawSerializationPipeline,\n    RawDebugRenderPipeline,\n} from \"../raw\";\n\nimport {\n    BroadPhase,\n    Collider,\n    ColliderDesc,\n    ColliderHandle,\n    ColliderSet,\n    InteractionGroups,\n    NarrowPhase,\n    PointColliderProjection,\n    Ray,\n    RayColliderIntersection,\n    RayColliderToi,\n    Shape,\n    ShapeColliderTOI,\n    TempContactManifold,\n} from \"../geometry\";\nimport {\n    CCDSolver,\n    IntegrationParameters,\n    IslandManager,\n    ImpulseJoint,\n    ImpulseJointHandle,\n    MultibodyJoint,\n    MultibodyJointHandle,\n    JointData,\n    ImpulseJointSet,\n    MultibodyJointSet,\n    RigidBody,\n    RigidBodyDesc,\n    RigidBodyHandle,\n    RigidBodySet,\n} from \"../dynamics\";\nimport {Rotation, Vector, VectorOps} from \"../math\";\nimport {PhysicsPipeline} from \"./physics_pipeline\";\nimport {QueryFilterFlags, QueryPipeline} from \"./query_pipeline\";\nimport {SerializationPipeline} from \"./serialization_pipeline\";\nimport {EventQueue} from \"./event_queue\";\nimport {PhysicsHooks} from \"./physics_hooks\";\nimport {DebugRenderBuffers, DebugRenderPipeline} from \"./debug_render_pipeline\";\nimport {KinematicCharacterController} from \"../control\";\nimport {Coarena} from \"../coarena\";\n\n/**\n * The physics world.\n *\n * This contains all the data-structures necessary for creating and simulating\n * bodies with contacts, joints, and external forces.\n */\nexport class World {\n    public gravity: Vector;\n    integrationParameters: IntegrationParameters;\n    islands: IslandManager;\n    broadPhase: BroadPhase;\n    narrowPhase: NarrowPhase;\n    bodies: RigidBodySet;\n    colliders: ColliderSet;\n    impulseJoints: ImpulseJointSet;\n    multibodyJoints: MultibodyJointSet;\n    ccdSolver: CCDSolver;\n    queryPipeline: QueryPipeline;\n    physicsPipeline: PhysicsPipeline;\n    serializationPipeline: SerializationPipeline;\n    debugRenderPipeline: DebugRenderPipeline;\n    characterControllers: Set<KinematicCharacterController>;\n\n    /**\n     * Release the WASM memory occupied by this physics world.\n     *\n     * All the fields of this physics world will be freed as well,\n     * so there is no need to call their `.free()` methods individually.\n     */\n    public free() {\n        this.integrationParameters.free();\n        this.islands.free();\n        this.broadPhase.free();\n        this.narrowPhase.free();\n        this.bodies.free();\n        this.colliders.free();\n        this.impulseJoints.free();\n        this.multibodyJoints.free();\n        this.ccdSolver.free();\n        this.queryPipeline.free();\n        this.physicsPipeline.free();\n        this.serializationPipeline.free();\n        this.debugRenderPipeline.free();\n        this.characterControllers.forEach((controller) => controller.free());\n\n        this.integrationParameters = undefined;\n        this.islands = undefined;\n        this.broadPhase = undefined;\n        this.narrowPhase = undefined;\n        this.bodies = undefined;\n        this.colliders = undefined;\n        this.ccdSolver = undefined;\n        this.impulseJoints = undefined;\n        this.multibodyJoints = undefined;\n        this.queryPipeline = undefined;\n        this.physicsPipeline = undefined;\n        this.serializationPipeline = undefined;\n        this.debugRenderPipeline = undefined;\n        this.characterControllers = undefined;\n    }\n\n    constructor(\n        gravity: Vector,\n        rawIntegrationParameters?: RawIntegrationParameters,\n        rawIslands?: RawIslandManager,\n        rawBroadPhase?: RawBroadPhase,\n        rawNarrowPhase?: RawNarrowPhase,\n        rawBodies?: RawRigidBodySet,\n        rawColliders?: RawColliderSet,\n        rawImpulseJoints?: RawImpulseJointSet,\n        rawMultibodyJoints?: RawMultibodyJointSet,\n        rawCCDSolver?: RawCCDSolver,\n        rawQueryPipeline?: RawQueryPipeline,\n        rawPhysicsPipeline?: RawPhysicsPipeline,\n        rawSerializationPipeline?: RawSerializationPipeline,\n        rawDebugRenderPipeline?: RawDebugRenderPipeline,\n    ) {\n        this.gravity = gravity;\n        this.integrationParameters = new IntegrationParameters(\n            rawIntegrationParameters,\n        );\n        this.islands = new IslandManager(rawIslands);\n        this.broadPhase = new BroadPhase(rawBroadPhase);\n        this.narrowPhase = new NarrowPhase(rawNarrowPhase);\n        this.bodies = new RigidBodySet(rawBodies);\n        this.colliders = new ColliderSet(rawColliders);\n        this.impulseJoints = new ImpulseJointSet(rawImpulseJoints);\n        this.multibodyJoints = new MultibodyJointSet(rawMultibodyJoints);\n        this.ccdSolver = new CCDSolver(rawCCDSolver);\n        this.queryPipeline = new QueryPipeline(rawQueryPipeline);\n        this.physicsPipeline = new PhysicsPipeline(rawPhysicsPipeline);\n        this.serializationPipeline = new SerializationPipeline(\n            rawSerializationPipeline,\n        );\n        this.debugRenderPipeline = new DebugRenderPipeline(\n            rawDebugRenderPipeline,\n        );\n        this.characterControllers = new Set<KinematicCharacterController>();\n\n        this.impulseJoints.finalizeDeserialization(this.bodies);\n        this.bodies.finalizeDeserialization(this.colliders);\n        this.colliders.finalizeDeserialization(this.bodies);\n    }\n\n    public static fromRaw(raw: RawDeserializedWorld): World {\n        if (!raw) return null;\n\n        return new World(\n            VectorOps.fromRaw(raw.takeGravity()),\n            raw.takeIntegrationParameters(),\n            raw.takeIslandManager(),\n            raw.takeBroadPhase(),\n            raw.takeNarrowPhase(),\n            raw.takeBodies(),\n            raw.takeColliders(),\n            raw.takeImpulseJoints(),\n            raw.takeMultibodyJoints(),\n        );\n    }\n\n    /**\n     * Takes a snapshot of this world.\n     *\n     * Use `World.restoreSnapshot` to create a new physics world with a state identical to\n     * the state when `.takeSnapshot()` is called.\n     */\n    public takeSnapshot(): Uint8Array {\n        return this.serializationPipeline.serializeAll(\n            this.gravity,\n            this.integrationParameters,\n            this.islands,\n            this.broadPhase,\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            this.impulseJoints,\n            this.multibodyJoints,\n        );\n    }\n\n    /**\n     * Creates a new physics world from a snapshot.\n     *\n     * This new physics world will be an identical copy of the snapshoted physics world.\n     */\n    public static restoreSnapshot(data: Uint8Array): World {\n        let deser = new SerializationPipeline();\n        return deser.deserializeAll(data);\n    }\n\n    /**\n     * Computes all the lines (and their colors) needed to render the scene.\n     */\n    public debugRender(): DebugRenderBuffers {\n        this.debugRenderPipeline.render(\n            this.bodies,\n            this.colliders,\n            this.impulseJoints,\n            this.multibodyJoints,\n            this.narrowPhase,\n        );\n        return new DebugRenderBuffers(\n            this.debugRenderPipeline.vertices,\n            this.debugRenderPipeline.colors,\n        );\n    }\n\n    /**\n     * Advance the simulation by one time step.\n     *\n     * All events generated by the physics engine are ignored.\n     *\n     * @param EventQueue - (optional) structure responsible for collecting\n     *   events generated by the physics engine.\n     */\n    public step(eventQueue?: EventQueue, hooks?: PhysicsHooks) {\n        this.physicsPipeline.step(\n            this.gravity,\n            this.integrationParameters,\n            this.islands,\n            this.broadPhase,\n            this.narrowPhase,\n            this.bodies,\n            this.colliders,\n            this.impulseJoints,\n            this.multibodyJoints,\n            this.ccdSolver,\n            eventQueue,\n            hooks,\n        );\n        this.queryPipeline.update(this.bodies, this.colliders);\n    }\n\n    /**\n     * Update colliders positions after rigid-bodies moved.\n     *\n     * When a rigid-body moves, the positions of the colliders attached to it need to be updated. This update is\n     * generally automatically done at the beginning and the end of each simulation step with World.step.\n     * If the positions need to be updated without running a simulation step this method can be called manually.\n     */\n    public propagateModifiedBodyPositionsToColliders() {\n        this.bodies.raw.propagateModifiedBodyPositionsToColliders(\n            this.colliders.raw,\n        );\n    }\n\n    /**\n     * Ensure subsequent scene queries take into account the collider positions set before this method is called.\n     *\n     * This does not step the physics simulation forward.\n     */\n    public updateSceneQueries() {\n        this.propagateModifiedBodyPositionsToColliders();\n        this.queryPipeline.update(this.bodies, this.colliders);\n    }\n\n    /**\n     * The current simulation timestep.\n     */\n    get timestep(): number {\n        return this.integrationParameters.dt;\n    }\n\n    /**\n     * Sets the new simulation timestep.\n     *\n     * The simulation timestep governs by how much the physics state of the world will\n     * be integrated. A simulation timestep should:\n     * - be as small as possible. Typical values evolve around 0.016 (assuming the chosen unit is milliseconds,\n     * corresponds to the time between two frames of a game running at 60FPS).\n     * - not vary too much during the course of the simulation. A timestep with large variations may\n     * cause instabilities in the simulation.\n     *\n     * @param dt - The timestep length, in seconds.\n     */\n    set timestep(dt: number) {\n        this.integrationParameters.dt = dt;\n    }\n\n    /**\n     * The maximum velocity iterations the velocity-based force constraint solver can make.\n     */\n    get maxVelocityIterations(): number {\n        return this.integrationParameters.maxVelocityIterations;\n    }\n\n    /**\n     * Sets the maximum number of velocity iterations (default: 4).\n     *\n     * The greater this value is, the most rigid and realistic the physics simulation will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new maximum number of velocity iterations.\n     */\n    set maxVelocityIterations(niter: number) {\n        this.integrationParameters.maxVelocityIterations = niter;\n    }\n\n    /**\n     * The maximum velocity iterations the velocity-based friction constraint solver can make.\n     */\n    get maxVelocityFrictionIterations(): number {\n        return this.integrationParameters.maxVelocityFrictionIterations;\n    }\n\n    /**\n     * Sets the maximum number of velocity iterations for friction (default: 8).\n     *\n     * The greater this value is, the most realistic friction will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new maximum number of velocity iterations.\n     */\n    set maxVelocityFrictionIterations(niter: number) {\n        this.integrationParameters.maxVelocityFrictionIterations = niter;\n    }\n\n    /**\n     * The maximum velocity iterations the velocity-based constraint solver can make to attempt to remove\n     * the energy introduced by constraint stabilization.\n     */\n    get maxStabilizationIterations(): number {\n        return this.integrationParameters.maxStabilizationIterations;\n    }\n\n    /**\n     * Sets the maximum number of velocity iterations for stabilization (default: 1).\n     *\n     * @param niter - The new maximum number of velocity iterations.\n     */\n    set maxStabilizationIterations(niter: number) {\n        this.integrationParameters.maxStabilizationIterations = niter;\n    }\n\n    /**\n     * Creates a new rigid-body from the given rigd-body descriptior.\n     *\n     * @param body - The description of the rigid-body to create.\n     */\n    public createRigidBody(body: RigidBodyDesc): RigidBody {\n        return this.bodies.createRigidBody(this.colliders, body);\n    }\n\n    /**\n     * Creates a new character controller.\n     *\n     * @param offset - The artificial gap added between the characters chape and its environment.\n     */\n    public createCharacterController(\n        offset: number,\n    ): KinematicCharacterController {\n        let controller = new KinematicCharacterController(\n            offset,\n            this.integrationParameters,\n            this.bodies,\n            this.colliders,\n            this.queryPipeline,\n        );\n        this.characterControllers.add(controller);\n        return controller;\n    }\n\n    /**\n     * Removes a character controller from this world.\n     *\n     * @param controller - The character controller to remove.\n     */\n    public removeCharacterController(controller: KinematicCharacterController) {\n        this.characterControllers.delete(controller);\n        controller.free();\n    }\n\n    /**\n     * Creates a new collider.\n     *\n     * @param desc - The description of the collider.\n     * @param parent - The rigid-body this collider is attached to.\n     */\n    public createCollider(desc: ColliderDesc, parent?: RigidBody): Collider {\n        let parentHandle = parent ? parent.handle : undefined;\n        return this.colliders.createCollider(this.bodies, desc, parentHandle);\n    }\n\n    /**\n     * Creates a new impulse joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createImpulseJoint(\n        params: JointData,\n        parent1: RigidBody,\n        parent2: RigidBody,\n        wakeUp: boolean,\n    ): ImpulseJoint {\n        return this.impulseJoints.createJoint(\n            this.bodies,\n            params,\n            parent1.handle,\n            parent2.handle,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Creates a new multibody joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    public createMultibodyJoint(\n        params: JointData,\n        parent1: RigidBody,\n        parent2: RigidBody,\n        wakeUp: boolean,\n    ): MultibodyJoint {\n        return this.multibodyJoints.createJoint(\n            params,\n            parent1.handle,\n            parent2.handle,\n            wakeUp,\n        );\n    }\n\n    /**\n     * Retrieves a rigid-body from its handle.\n     *\n     * @param handle - The integer handle of the rigid-body to retrieve.\n     */\n    public getRigidBody(handle: RigidBodyHandle): RigidBody {\n        return this.bodies.get(handle);\n    }\n\n    /**\n     * Retrieves a collider from its handle.\n     *\n     * @param handle - The integer handle of the collider to retrieve.\n     */\n    public getCollider(handle: ColliderHandle): Collider {\n        return this.colliders.get(handle);\n    }\n\n    /**\n     * Retrieves an impulse joint from its handle.\n     *\n     * @param handle - The integer handle of the impulse joint to retrieve.\n     */\n    public getImpulseJoint(handle: ImpulseJointHandle): ImpulseJoint {\n        return this.impulseJoints.get(handle);\n    }\n\n    /**\n     * Retrieves an multibody joint from its handle.\n     *\n     * @param handle - The integer handle of the multibody joint to retrieve.\n     */\n    public getMultibodyJoint(handle: MultibodyJointHandle): MultibodyJoint {\n        return this.multibodyJoints.get(handle);\n    }\n\n    /**\n     * Removes the given rigid-body from this physics world.\n     *\n     * This will remove this rigid-body as well as all its attached colliders and joints.\n     * Every other bodies touching or attached by joints to this rigid-body will be woken-up.\n     *\n     * @param body - The rigid-body to remove.\n     */\n    public removeRigidBody(body: RigidBody) {\n        if (this.bodies) {\n            this.bodies.remove(\n                body.handle,\n                this.islands,\n                this.colliders,\n                this.impulseJoints,\n                this.multibodyJoints,\n            );\n        }\n    }\n\n    /**\n     * Removes the given collider from this physics world.\n     *\n     * @param collider - The collider to remove.\n     * @param wakeUp - If set to `true`, the rigid-body this collider is attached to will be awaken.\n     */\n    public removeCollider(collider: Collider, wakeUp: boolean) {\n        if (this.colliders) {\n            this.colliders.remove(\n                collider.handle,\n                this.islands,\n                this.bodies,\n                wakeUp,\n            );\n        }\n    }\n\n    /**\n     * Removes the given impulse joint from this physics world.\n     *\n     * @param joint - The impulse joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    public removeImpulseJoint(joint: ImpulseJoint, wakeUp: boolean) {\n        if (this.impulseJoints) {\n            this.impulseJoints.remove(joint.handle, wakeUp);\n        }\n    }\n\n    /**\n     * Removes the given multibody joint from this physics world.\n     *\n     * @param joint - The multibody joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    public removeMultibodyJoint(joint: MultibodyJoint, wakeUp: boolean) {\n        if (this.impulseJoints) {\n            this.multibodyJoints.remove(joint.handle, wakeUp);\n        }\n    }\n\n    /**\n     * Applies the given closure to each collider managed by this physics world.\n     *\n     * @param f(collider) - The function to apply to each collider managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachCollider(f: (collider: Collider) => void) {\n        this.colliders.forEach(f);\n    }\n\n    /**\n     * Applies the given closure to each rigid-body managed by this physics world.\n     *\n     * @param f(body) - The function to apply to each rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachRigidBody(f: (body: RigidBody) => void) {\n        this.bodies.forEach(f);\n    }\n\n    /**\n     * Applies the given closure to each active rigid-body managed by this physics world.\n     *\n     * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n     * the physics engine in order to save computational power. A sleeping rigid-body never moves\n     * unless it is moved manually by the user.\n     *\n     * @param f - The function to apply to each active rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    public forEachActiveRigidBody(f: (body: RigidBody) => void) {\n        this.bodies.forEachActiveRigidBody(this.islands, f);\n    }\n\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    public castRay(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): RayColliderToi | null {\n        return this.queryPipeline.castRay(\n            this.bodies,\n            this.colliders,\n            ray,\n            maxToi,\n            solid,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    public castRayAndGetNormal(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): RayColliderIntersection | null {\n        return this.queryPipeline.castRayAndGetNormal(\n            this.bodies,\n            this.colliders,\n            ray,\n            maxToi,\n            solid,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    public intersectionsWithRay(\n        ray: Ray,\n        maxToi: number,\n        solid: boolean,\n        callback: (intersect: RayColliderIntersection) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.queryPipeline.intersectionsWithRay(\n            this.bodies,\n            this.colliders,\n            ray,\n            maxToi,\n            solid,\n            callback,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    public intersectionWithShape(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): Collider | null {\n        let handle = this.queryPipeline.intersectionWithShape(\n            this.bodies,\n            this.colliders,\n            shapePos,\n            shapeRot,\n            shape,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n        return handle != null ? this.colliders.get(handle) : null;\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPoint(\n        point: Vector,\n        solid: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): PointColliderProjection | null {\n        return this.queryPipeline.projectPoint(\n            this.bodies,\n            this.colliders,\n            point,\n            solid,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    public projectPointAndGetFeature(\n        point: Vector,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): PointColliderProjection | null {\n        return this.queryPipeline.projectPointAndGetFeature(\n            this.bodies,\n            this.colliders,\n            point,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    public intersectionsWithPoint(\n        point: Vector,\n        callback: (handle: Collider) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.queryPipeline.intersectionsWithPoint(\n            this.bodies,\n            this.colliders,\n            point,\n            this.colliders.castClosure(callback),\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    public castShape(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shapeVel: Vector,\n        shape: Shape,\n        maxToi: number,\n        stopAtPenetration: boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ): ShapeColliderTOI | null {\n        return this.queryPipeline.castShape(\n            this.bodies,\n            this.colliders,\n            shapePos,\n            shapeRot,\n            shapeVel,\n            shape,\n            maxToi,\n            stopAtPenetration,\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    public intersectionsWithShape(\n        shapePos: Vector,\n        shapeRot: Rotation,\n        shape: Shape,\n        callback: (collider: Collider) => boolean,\n        filterFlags?: QueryFilterFlags,\n        filterGroups?: InteractionGroups,\n        filterExcludeCollider?: Collider,\n        filterExcludeRigidBody?: RigidBody,\n        filterPredicate?: (collider: Collider) => boolean,\n    ) {\n        this.queryPipeline.intersectionsWithShape(\n            this.bodies,\n            this.colliders,\n            shapePos,\n            shapeRot,\n            shape,\n            this.colliders.castClosure(callback),\n            filterFlags,\n            filterGroups,\n            filterExcludeCollider ? filterExcludeCollider.handle : null,\n            filterExcludeRigidBody ? filterExcludeRigidBody.handle : null,\n            this.colliders.castClosure(filterPredicate),\n        );\n    }\n\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    public collidersWithAabbIntersectingAabb(\n        aabbCenter: Vector,\n        aabbHalfExtents: Vector,\n        callback: (handle: Collider) => boolean,\n    ) {\n        this.queryPipeline.collidersWithAabbIntersectingAabb(\n            aabbCenter,\n            aabbHalfExtents,\n            this.colliders.castClosure(callback),\n        );\n    }\n\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    public contactsWith(collider1: Collider, f: (collider2: Collider) => void) {\n        this.narrowPhase.contactsWith(\n            collider1.handle,\n            this.colliders.castClosure(f),\n        );\n    }\n\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    public intersectionsWith(\n        collider1: Collider,\n        f: (collider2: Collider) => void,\n    ) {\n        this.narrowPhase.intersectionsWith(\n            collider1.handle,\n            this.colliders.castClosure(f),\n        );\n    }\n\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    public contactPair(\n        collider1: Collider,\n        collider2: Collider,\n        f: (manifold: TempContactManifold, flipped: boolean) => void,\n    ) {\n        this.narrowPhase.contactPair(collider1.handle, collider2.handle, f);\n    }\n\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1  The first collider involved in the intersection.\n     * @param collider2  The second collider involved in the intersection.\n     */\n    public intersectionPair(collider1: Collider, collider2: Collider): boolean {\n        return this.narrowPhase.intersectionPair(\n            collider1.handle,\n            collider2.handle,\n        );\n    }\n}\n","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","// @ts-ignore\nimport wasmBase64 from \"../pkg3d/rapier_wasm3d_bg.wasm\";\nimport wasmInit from \"../pkg3d/rapier_wasm3d\";\nimport base64 from \"base64-js\";\n\n/**\n * Initializes RAPIER.\n * Has to be called and awaited before using any library methods.\n */\nexport async function init() {\n    await wasmInit(base64.toByteArray(wasmBase64 as unknown as string).buffer);\n}\n","import {version as vers} from \"./raw\";\n\nexport function version(): string {\n    return vers();\n}\n\nexport * from \"./math\";\nexport * from \"./dynamics\";\nexport * from \"./geometry\";\nexport * from \"./pipeline\";\nexport * from \"./init\";\nexport * from \"./control\";\n"],"names":["wasm","heap","Array","fill","undefined","getObject","idx","push","heap_next","length","takeObject","ret","dropObject","addHeapObject","obj","isLikeNone","x","cachedFloat64Memory0","Float64Array","getFloat64Memory0","byteLength","memory","buffer","cachedInt32Memory0","Int32Array","getInt32Memory0","cachedTextDecoder","TextDecoder","ignoreBOM","fatal","decode","cachedUint8Memory0","Uint8Array","getStringFromWasm0","ptr","len","subarray","_assertClass","instance","klass","Error","name","cachedFloat32Memory0","Float32Array","getFloat32Memory0","stack_pointer","addBorrowedObject","getArrayF32FromWasm0","cachedUint32Memory0","Uint32Array","getUint32Memory0","WASM_VECTOR_LEN","passArrayF32ToWasm0","arg","malloc","set","passArray32ToWasm0","handleError","f","args","apply","this","e","__wbindgen_exn_store","Object","freeze","Revolute","Fixed","Prismatic","Spherical","Generic","AccelerationBased","ForceBased","RawJointAxis","X","Y","Z","AngX","AngY","AngZ","Dynamic","KinematicPositionBased","KinematicVelocityBased","Vertex","Edge","Face","Unknown","Ball","Cuboid","Capsule","Segment","Polyline","Triangle","TriMesh","HeightField","Compound","ConvexPolyhedron","Cylinder","Cone","RoundCuboid","RoundTriangle","RoundCylinder","RoundCone","RoundConvexPolyhedron","HalfSpace","RawBroadPhase","static","create","prototype","__destroy_into_raw","free","__wbg_rawbroadphase_free","constructor","rawbroadphase_new","__wrap","RawCCDSolver","__wbg_rawccdsolver_free","rawccdsolver_new","RawCharacterCollision","__wbg_rawcharactercollision_free","rawcharactercollision_new","handle","rawcharactercollision_handle","translationApplied","rawcharactercollision_translationApplied","RawVector","translationRemaining","rawcharactercollision_translationRemaining","toi","rawcharactercollision_toi","worldWitness1","rawcharactercollision_worldWitness1","worldWitness2","rawcharactercollision_worldWitness2","worldNormal1","rawcharactercollision_worldNormal1","worldNormal2","rawcharactercollision_worldNormal2","RawColliderSet","__wbg_rawcolliderset_free","coTranslation","rawcolliderset_coTranslation","coRotation","rawcolliderset_coRotation","RawRotation","coSetTranslation","y","z","rawcolliderset_coSetTranslation","coSetTranslationWrtParent","rawcolliderset_coSetTranslationWrtParent","coSetRotation","w","rawcolliderset_coSetRotation","coSetRotationWrtParent","rawcolliderset_coSetRotationWrtParent","coIsSensor","rawcolliderset_coIsSensor","coShapeType","rawcolliderset_coShapeType","coHalfspaceNormal","rawcolliderset_coHalfspaceNormal","coHalfExtents","rawcolliderset_coHalfExtents","coSetHalfExtents","newHalfExtents","rawcolliderset_coSetHalfExtents","coRadius","retptr","__wbindgen_add_to_stack_pointer","rawcolliderset_coRadius","r0","r1","coSetRadius","newRadius","rawcolliderset_coSetRadius","coHalfHeight","rawcolliderset_coHalfHeight","coSetHalfHeight","newHalfheight","rawcolliderset_coSetHalfHeight","coRoundRadius","rawcolliderset_coRoundRadius","coSetRoundRadius","newBorderRadius","rawcolliderset_coSetRoundRadius","coVertices","rawcolliderset_coVertices","v0","slice","__wbindgen_free","coIndices","rawcolliderset_coIndices","getArrayU32FromWasm0","coHeightfieldHeights","rawcolliderset_coHeightfieldHeights","coHeightfieldScale","rawcolliderset_coHeightfieldScale","coHeightfieldNRows","rawcolliderset_coHeightfieldNRows","coHeightfieldNCols","rawcolliderset_coHeightfieldNCols","coParent","rawcolliderset_coParent","r2","coSetEnabled","enabled","rawcolliderset_coSetEnabled","coIsEnabled","rawcolliderset_coIsEnabled","coFriction","rawcolliderset_coFriction","coRestitution","rawcolliderset_coRestitution","coDensity","rawcolliderset_coDensity","coMass","rawcolliderset_coMass","coVolume","rawcolliderset_coVolume","coCollisionGroups","rawcolliderset_coCollisionGroups","coSolverGroups","rawcolliderset_coSolverGroups","coActiveHooks","rawcolliderset_coActiveHooks","coActiveCollisionTypes","rawcolliderset_coActiveCollisionTypes","coActiveEvents","rawcolliderset_coActiveEvents","coContactForceEventThreshold","rawcolliderset_coContactForceEventThreshold","coContainsPoint","point","rawcolliderset_coContainsPoint","coCastShape","colliderVel","shape2","shape2Pos","shape2Rot","shape2Vel","maxToi","stop_at_penetration","RawShape","rawcolliderset_coCastShape","RawShapeTOI","coCastCollider","collider1Vel","collider2handle","collider2Vel","max_toi","rawcolliderset_coCastCollider","RawShapeColliderTOI","coIntersectsShape","shapePos2","shapeRot2","rawcolliderset_coIntersectsShape","coContactShape","prediction","rawcolliderset_coContactShape","RawShapeContact","coContactCollider","rawcolliderset_coContactCollider","coProjectPoint","solid","rawcolliderset_coProjectPoint","RawPointProjection","coIntersectsRay","rayOrig","rayDir","rawcolliderset_coIntersectsRay","coCastRay","rawcolliderset_coCastRay","coCastRayAndGetNormal","rawcolliderset_coCastRayAndGetNormal","RawRayIntersection","coSetSensor","is_sensor","rawcolliderset_coSetSensor","coSetRestitution","restitution","rawcolliderset_coSetRestitution","coSetFriction","friction","rawcolliderset_coSetFriction","coFrictionCombineRule","rawcolliderset_coFrictionCombineRule","coSetFrictionCombineRule","rule","rawcolliderset_coSetFrictionCombineRule","coRestitutionCombineRule","rawcolliderset_coRestitutionCombineRule","coSetRestitutionCombineRule","rawcolliderset_coSetRestitutionCombineRule","coSetCollisionGroups","groups","rawcolliderset_coSetCollisionGroups","coSetSolverGroups","rawcolliderset_coSetSolverGroups","coSetActiveHooks","hooks","rawcolliderset_coSetActiveHooks","coSetActiveEvents","events","rawcolliderset_coSetActiveEvents","coSetActiveCollisionTypes","types","rawcolliderset_coSetActiveCollisionTypes","coSetShape","shape","rawcolliderset_coSetShape","coSetContactForceEventThreshold","threshold","rawcolliderset_coSetContactForceEventThreshold","coSetDensity","density","rawcolliderset_coSetDensity","coSetMass","mass","rawcolliderset_coSetMass","coSetMassProperties","centerOfMass","principalAngularInertia","angularInertiaFrame","rawcolliderset_coSetMassProperties","rawcolliderset_new","rawcolliderset_len","contains","rawcolliderset_contains","createCollider","translation","rotation","massPropsMode","frictionCombineRule","restitutionCombineRule","isSensor","collisionGroups","solverGroups","activeCollisionTypes","activeHooks","activeEvents","contactForceEventThreshold","hasParent","parent","bodies","RawRigidBodySet","rawcolliderset_createCollider","remove","islands","wakeUp","RawIslandManager","rawcolliderset_remove","isHandleValid","forEachColliderHandle","rawcolliderset_forEachColliderHandle","RawContactForceEvent","__wbg_rawcontactforceevent_free","collider1","collider2","rawcontactforceevent_collider2","total_force","rawcontactforceevent_total_force","total_force_magnitude","rawcontactforceevent_total_force_magnitude","max_force_direction","rawcontactforceevent_max_force_direction","max_force_magnitude","rawcontactforceevent_max_force_magnitude","RawContactManifold","__wbg_rawcontactmanifold_free","normal","rawcontactmanifold_normal","local_n1","rawcontactmanifold_local_n1","local_n2","rawcontactmanifold_local_n2","subshape1","rawcontactmanifold_subshape1","subshape2","rawcontactmanifold_subshape2","num_contacts","rawcontactmanifold_num_contacts","contact_local_p1","i","rawcontactmanifold_contact_local_p1","contact_local_p2","rawcontactmanifold_contact_local_p2","contact_dist","rawcontactmanifold_contact_dist","contact_fid1","rawcontactmanifold_contact_fid1","contact_fid2","rawcontactmanifold_contact_fid2","contact_impulse","rawcontactmanifold_contact_impulse","contact_tangent_impulse_x","rawcontactmanifold_contact_tangent_impulse_x","contact_tangent_impulse_y","rawcontactmanifold_contact_tangent_impulse_y","num_solver_contacts","rawcontactmanifold_num_solver_contacts","solver_contact_point","rawcontactmanifold_solver_contact_point","solver_contact_dist","rawcontactmanifold_solver_contact_dist","solver_contact_friction","rawcontactmanifold_solver_contact_friction","solver_contact_restitution","rawcontactmanifold_solver_contact_restitution","solver_contact_tangent_velocity","rawcontactmanifold_solver_contact_tangent_velocity","RawContactPair","__wbg_rawcontactpair_free","rawcontactpair_collider1","rawcontactpair_collider2","numContactManifolds","rawcontactpair_numContactManifolds","contactManifold","rawcontactpair_contactManifold","RawDebugRenderPipeline","__wbg_rawdebugrenderpipeline_free","rawdebugrenderpipeline_new","vertices","rawdebugrenderpipeline_vertices","colors","rawdebugrenderpipeline_colors","render","colliders","impulse_joints","multibody_joints","narrow_phase","RawImpulseJointSet","RawMultibodyJointSet","RawNarrowPhase","rawdebugrenderpipeline_render","RawDeserializedWorld","__wbg_rawdeserializedworld_free","takeGravity","rawdeserializedworld_takeGravity","takeIntegrationParameters","rawdeserializedworld_takeIntegrationParameters","RawIntegrationParameters","takeIslandManager","rawdeserializedworld_takeIslandManager","takeBroadPhase","rawdeserializedworld_takeBroadPhase","takeNarrowPhase","rawdeserializedworld_takeNarrowPhase","takeBodies","rawdeserializedworld_takeBodies","takeColliders","rawdeserializedworld_takeColliders","takeImpulseJoints","rawdeserializedworld_takeImpulseJoints","takeMultibodyJoints","rawdeserializedworld_takeMultibodyJoints","RawEventQueue","__wbg_raweventqueue_free","autoDrain","raweventqueue_new","drainCollisionEvents","raweventqueue_drainCollisionEvents","drainContactForceEvents","raweventqueue_drainContactForceEvents","clear","raweventqueue_clear","RawGenericJoint","__wbg_rawgenericjoint_free","anchor1","anchor2","rawgenericjoint_spherical","axis","limitsEnabled","limitsMin","limitsMax","rawgenericjoint_prismatic","axes1","axes2","rawgenericjoint_fixed","rawgenericjoint_revolute","__wbg_rawimpulsejointset_free","jointType","rawimpulsejointset_jointType","jointBodyHandle1","rawimpulsejointset_jointBodyHandle1","jointBodyHandle2","rawimpulsejointset_jointBodyHandle2","jointFrameX1","rawimpulsejointset_jointFrameX1","jointFrameX2","rawimpulsejointset_jointFrameX2","jointAnchor1","rawimpulsejointset_jointAnchor1","jointAnchor2","rawimpulsejointset_jointAnchor2","jointSetAnchor1","newPos","rawimpulsejointset_jointSetAnchor1","jointSetAnchor2","rawimpulsejointset_jointSetAnchor2","jointContactsEnabled","rawimpulsejointset_jointContactsEnabled","jointSetContactsEnabled","rawimpulsejointset_jointSetContactsEnabled","jointLimitsEnabled","rawimpulsejointset_jointLimitsEnabled","jointLimitsMin","rawimpulsejointset_jointLimitsMin","jointLimitsMax","rawimpulsejointset_jointLimitsMax","jointSetLimits","min","max","rawimpulsejointset_jointSetLimits","jointConfigureMotorModel","model","rawimpulsejointset_jointConfigureMotorModel","jointConfigureMotorVelocity","targetVel","factor","rawimpulsejointset_jointConfigureMotorVelocity","jointConfigureMotorPosition","targetPos","stiffness","damping","rawimpulsejointset_jointConfigureMotorPosition","jointConfigureMotor","rawimpulsejointset_jointConfigureMotor","rawimpulsejointset_new","createJoint","params","parent1","parent2","wake_up","rawimpulsejointset_createJoint","rawimpulsejointset_remove","rawimpulsejointset_len","rawimpulsejointset_contains","forEachJointHandle","rawimpulsejointset_forEachJointHandle","forEachJointAttachedToRigidBody","body","rawimpulsejointset_forEachJointAttachedToRigidBody","__wbg_rawintegrationparameters_free","rawintegrationparameters_new","dt","rawintegrationparameters_dt","erp","allowedLinearError","rawintegrationparameters_allowedLinearError","predictionDistance","rawintegrationparameters_predictionDistance","maxVelocityIterations","rawintegrationparameters_maxVelocityIterations","maxVelocityFrictionIterations","rawintegrationparameters_maxVelocityFrictionIterations","maxStabilizationIterations","rawintegrationparameters_maxStabilizationIterations","minIslandSize","rawintegrationparameters_minIslandSize","maxCcdSubsteps","rawintegrationparameters_maxCcdSubsteps","value","rawintegrationparameters_set_dt","rawintegrationparameters_set_erp","rawintegrationparameters_set_allowedLinearError","rawintegrationparameters_set_predictionDistance","rawintegrationparameters_set_maxVelocityIterations","rawintegrationparameters_set_maxVelocityFrictionIterations","rawintegrationparameters_set_maxStabilizationIterations","rawintegrationparameters_set_minIslandSize","rawintegrationparameters_set_maxCcdSubsteps","__wbg_rawislandmanager_free","rawislandmanager_new","forEachActiveRigidBodyHandle","rawislandmanager_forEachActiveRigidBodyHandle","RawKinematicCharacterController","__wbg_rawkinematiccharactercontroller_free","offset","rawkinematiccharactercontroller_new","up","rawkinematiccharactercontroller_up","setUp","vector","rawkinematiccharactercontroller_setUp","rawkinematiccharactercontroller_offset","setOffset","rawkinematiccharactercontroller_setOffset","slideEnabled","rawkinematiccharactercontroller_slideEnabled","setSlideEnabled","rawkinematiccharactercontroller_setSlideEnabled","autostepMaxHeight","rawkinematiccharactercontroller_autostepMaxHeight","autostepMinWidth","rawkinematiccharactercontroller_autostepMinWidth","autostepIncludesDynamicBodies","rawkinematiccharactercontroller_autostepIncludesDynamicBodies","autostepEnabled","rawkinematiccharactercontroller_autostepEnabled","enableAutostep","maxHeight","minWidth","includeDynamicBodies","rawkinematiccharactercontroller_enableAutostep","disableAutostep","rawkinematiccharactercontroller_disableAutostep","maxSlopeClimbAngle","rawkinematiccharactercontroller_maxSlopeClimbAngle","setMaxSlopeClimbAngle","angle","rawkinematiccharactercontroller_setMaxSlopeClimbAngle","minSlopeSlideAngle","rawkinematiccharactercontroller_minSlopeSlideAngle","setMinSlopeSlideAngle","rawkinematiccharactercontroller_setMinSlopeSlideAngle","snapToGroundDistance","rawkinematiccharactercontroller_snapToGroundDistance","enableSnapToGround","distance","rawkinematiccharactercontroller_enableSnapToGround","disableSnapToGround","rawkinematiccharactercontroller_disableSnapToGround","snapToGroundEnabled","rawkinematiccharactercontroller_snapToGroundEnabled","computeColliderMovement","queries","collider_handle","desired_translation","apply_impulses_to_dynamic_bodies","character_mass","filter_flags","filter_groups","filter_predicate","RawQueryPipeline","rawkinematiccharactercontroller_computeColliderMovement","computedMovement","rawkinematiccharactercontroller_computedMovement","computedGrounded","rawkinematiccharactercontroller_computedGrounded","numComputedCollisions","rawkinematiccharactercontroller_numComputedCollisions","computedCollision","collision","rawkinematiccharactercontroller_computedCollision","__wbg_rawmultibodyjointset_free","rawmultibodyjointset_jointType","rawmultibodyjointset_jointFrameX1","rawmultibodyjointset_jointFrameX2","rawmultibodyjointset_jointAnchor1","rawmultibodyjointset_jointAnchor2","rawmultibodyjointset_jointContactsEnabled","rawmultibodyjointset_jointSetContactsEnabled","rawmultibodyjointset_jointLimitsEnabled","rawmultibodyjointset_jointLimitsMin","rawmultibodyjointset_jointLimitsMax","rawmultibodyjointset_new","rawmultibodyjointset_createJoint","rawmultibodyjointset_remove","rawmultibodyjointset_contains","rawmultibodyjointset_forEachJointHandle","rawmultibodyjointset_forEachJointAttachedToRigidBody","__wbg_rawnarrowphase_free","rawnarrowphase_new","contacts_with","handle1","rawnarrowphase_contacts_with","contact_pair","handle2","rawnarrowphase_contact_pair","intersections_with","rawnarrowphase_intersections_with","intersection_pair","rawnarrowphase_intersection_pair","RawPhysicsPipeline","__wbg_rawphysicspipeline_free","rawphysicspipeline_new","step","gravity","integrationParameters","broadPhase","narrowPhase","joints","articulations","ccd_solver","rawphysicspipeline_step","stepWithEvents","eventQueue","hookObject","hookFilterContactPair","hookFilterIntersectionPair","rawphysicspipeline_stepWithEvents","RawPointColliderProjection","__wbg_rawpointcolliderprojection_free","colliderHandle","rawpointcolliderprojection_colliderHandle","isInside","featureType","rawpointcolliderprojection_featureType","featureId","rawpointcolliderprojection_featureId","__wbg_rawpointprojection_free","__wbg_rawquerypipeline_free","rawquerypipeline_new","update","rawquerypipeline_update","castRay","filter_exclude_collider","filter_exclude_rigid_body","rawquerypipeline_castRay","RawRayColliderToi","castRayAndGetNormal","rawquerypipeline_castRayAndGetNormal","RawRayColliderIntersection","intersectionsWithRay","callback","rawquerypipeline_intersectionsWithRay","intersectionWithShape","shapePos","shapeRot","rawquerypipeline_intersectionWithShape","projectPoint","rawquerypipeline_projectPoint","projectPointAndGetFeature","rawquerypipeline_projectPointAndGetFeature","intersectionsWithPoint","rawquerypipeline_intersectionsWithPoint","castShape","shapeVel","rawquerypipeline_castShape","intersectionsWithShape","rawquerypipeline_intersectionsWithShape","collidersWithAabbIntersectingAabb","aabbCenter","aabbHalfExtents","rawquerypipeline_collidersWithAabbIntersectingAabb","__wbg_rawraycolliderintersection_free","rawraycolliderintersection_normal","rawraycolliderintersection_toi","rawraycolliderintersection_featureType","rawraycolliderintersection_featureId","__wbg_rawraycollidertoi_free","__wbg_rawrayintersection_free","rawrayintersection_featureType","rawrayintersection_featureId","__wbg_rawrigidbodyset_free","rbTranslation","rawrigidbodyset_rbTranslation","rbRotation","rawrigidbodyset_rbRotation","rbSleep","rawrigidbodyset_rbSleep","rbIsSleeping","rawrigidbodyset_rbIsSleeping","rbIsMoving","rawrigidbodyset_rbIsMoving","rbNextTranslation","rawrigidbodyset_rbNextTranslation","rbNextRotation","rawrigidbodyset_rbNextRotation","rbSetTranslation","rawrigidbodyset_rbSetTranslation","rbSetRotation","rawrigidbodyset_rbSetRotation","rbSetLinvel","linvel","rawrigidbodyset_rbSetLinvel","rbSetAngvel","angvel","rawrigidbodyset_rbSetAngvel","rbSetNextKinematicTranslation","rawrigidbodyset_rbSetNextKinematicTranslation","rbSetNextKinematicRotation","rawrigidbodyset_rbSetNextKinematicRotation","rbRecomputeMassPropertiesFromColliders","rawrigidbodyset_rbRecomputeMassPropertiesFromColliders","rbSetAdditionalMass","rawrigidbodyset_rbSetAdditionalMass","rbSetAdditionalMassProperties","rawrigidbodyset_rbSetAdditionalMassProperties","rbLinvel","rawrigidbodyset_rbLinvel","rbAngvel","rawrigidbodyset_rbAngvel","rbLockTranslations","locked","rawrigidbodyset_rbLockTranslations","rbSetEnabledTranslations","allow_x","allow_y","allow_z","rawrigidbodyset_rbSetEnabledTranslations","rbLockRotations","rawrigidbodyset_rbLockRotations","rbSetEnabledRotations","rawrigidbodyset_rbSetEnabledRotations","rbDominanceGroup","rawrigidbodyset_rbDominanceGroup","rbSetDominanceGroup","group","rawrigidbodyset_rbSetDominanceGroup","rbEnableCcd","rawrigidbodyset_rbEnableCcd","rbMass","rawrigidbodyset_rbMass","rbWakeUp","rawrigidbodyset_rbWakeUp","rbIsCcdEnabled","rawrigidbodyset_rbIsCcdEnabled","rbNumColliders","rawrigidbodyset_rbNumColliders","rbCollider","at","rawrigidbodyset_rbCollider","rbBodyType","rawrigidbodyset_rbBodyType","rbSetBodyType","status","rawrigidbodyset_rbSetBodyType","rbIsFixed","rawrigidbodyset_rbIsFixed","rbIsKinematic","rawrigidbodyset_rbIsKinematic","rbIsDynamic","rawrigidbodyset_rbIsDynamic","rbLinearDamping","rawrigidbodyset_rbLinearDamping","rbAngularDamping","rawrigidbodyset_rbAngularDamping","rbSetLinearDamping","rawrigidbodyset_rbSetLinearDamping","rbSetAngularDamping","rawrigidbodyset_rbSetAngularDamping","rbSetEnabled","rawrigidbodyset_rbSetEnabled","rbIsEnabled","rawrigidbodyset_rbIsEnabled","rbGravityScale","rawrigidbodyset_rbGravityScale","rbSetGravityScale","rawrigidbodyset_rbSetGravityScale","rbResetForces","rawrigidbodyset_rbResetForces","rbResetTorques","rawrigidbodyset_rbResetTorques","rbAddForce","force","rawrigidbodyset_rbAddForce","rbApplyImpulse","impulse","rawrigidbodyset_rbApplyImpulse","rbAddTorque","torque","rawrigidbodyset_rbAddTorque","rbApplyTorqueImpulse","torque_impulse","rawrigidbodyset_rbApplyTorqueImpulse","rbAddForceAtPoint","rawrigidbodyset_rbAddForceAtPoint","rbApplyImpulseAtPoint","rawrigidbodyset_rbApplyImpulseAtPoint","rbUserData","rawrigidbodyset_rbUserData","rbSetUserData","data","rawrigidbodyset_rbSetUserData","rawrigidbodyset_new","createRigidBody","gravityScale","massOnly","translationEnabledX","translationEnabledY","translationEnabledZ","rotationEnabledX","rotationEnabledY","rotationEnabledZ","linearDamping","angularDamping","rb_type","canSleep","sleeping","ccdEnabled","dominanceGroup","rawrigidbodyset_createRigidBody","rawrigidbodyset_remove","rawrigidbodyset_len","rawrigidbodyset_contains","forEachRigidBodyHandle","rawrigidbodyset_forEachRigidBodyHandle","propagateModifiedBodyPositionsToColliders","rawrigidbodyset_propagateModifiedBodyPositionsToColliders","__wbg_rawrotation_free","rawrotation_new","rawrotation_identity","rawrotation_y","rawrotation_w","RawSerializationPipeline","__wbg_rawserializationpipeline_free","rawserializationpipeline_new","serializeAll","rawserializationpipeline_serializeAll","deserializeAll","rawserializationpipeline_deserializeAll","__wbg_rawshape_free","hx","hy","hz","rawshape_cuboid","borderRadius","rawshape_roundCuboid","radius","rawshape_ball","rawshape_halfspace","halfHeight","rawshape_capsule","rawshape_cylinder","rawshape_roundCylinder","rawshape_cone","rawshape_roundCone","indices","ptr0","__wbindgen_malloc","len0","ptr1","len1","rawshape_polyline","rawshape_trimesh","nrows","ncols","heights","scale","rawshape_heightfield","p1","p2","rawshape_segment","p3","rawshape_triangle","rawshape_roundTriangle","points","rawshape_convexHull","rawshape_roundConvexHull","rawshape_convexMesh","rawshape_roundConvexMesh","shapePos1","shapeRot1","shapeVel1","shapeVel2","rawshape_castShape","intersectsShape","rawshape_intersectsShape","contactShape","rawshape_contactShape","containsPoint","rawshape_containsPoint","rawshape_projectPoint","intersectsRay","rawshape_intersectsRay","rawshape_castRay","rawshape_castRayAndGetNormal","__wbg_rawshapecollidertoi_free","witness1","witness2","rawshapecollidertoi_witness2","normal1","normal2","rawshapecollidertoi_normal2","__wbg_rawshapecontact_free","rawshapecontact_distance","point1","point2","__wbg_rawshapetoi_free","rawshapetoi_witness1","rawshapetoi_normal1","rawshapetoi_normal2","__wbg_rawvector_free","rawvector_zero","rawvector_new","rawvector_set_y","xyz","rawvector_xyz","yxz","rawvector_yxz","zxy","rawvector_zxy","xzy","rawvector_xzy","yzx","rawvector_yzx","zyx","rawvector_zyx","async","init","input","URL","imports","wbg","__wbindgen_object_drop_ref","arg0","__wbindgen_number_new","__wbindgen_number_get","arg1","__wbindgen_boolean_get","v","__wbindgen_is_function","__wbg_rawraycolliderintersection_new","__wbg_rawcontactforceevent_new","__wbg_call_168da88779e35f61","arg2","call","arguments","__wbg_call_3999bee59e9f7719","arg3","__wbg_call_e1f72c051cdab859","arg4","__wbg_bind_10dfe70e95d2a480","bind","__wbg_buffer_3f3d764d4747d564","__wbg_newwithbyteoffsetandlength_d9aa266703cb98be","__wbg_new_8c3f0052272a457a","__wbg_set_83db9690f9353e79","__wbg_length_9e1ae1900cb0fbd5","__wbg_newwithbyteoffsetandlength_be22e5fcf4f69ab4","__wbg_set_0e0314cf6675c1b9","__wbg_length_9a2deed95d22668d","__wbg_newwithlength_a7168e4a1e8f5e12","__wbindgen_throw","__wbindgen_memory","getImports","Request","fetch","module","Response","WebAssembly","instantiateStreaming","headers","get","console","warn","bytes","arrayBuffer","instantiate","Instance","load","exports","__wbindgen_wasm_module","finalizeInit","Vector3","VectorOps","new","raw","res","out","Quaternion","RotationOps","rot","RigidBodyType","JointType","MotorModel","CoefficientCombineRule","FeatureType","ShapeType","ActiveCollisionTypes","MassPropsMode","QueryFilterFlags","ActiveEvents","ActiveHooks","SolverFlags","RigidBody","rawSet","colliderSet","finalizeDeserialization","isValid","lockTranslations","lockRotations","setEnabledTranslations","enableX","enableY","enableZ","restrictTranslations","setEnabledRotations","restrictRotations","setDominanceGroup","enableCcd","fromRaw","nextTranslation","nextRotation","setTranslation","tra","setLinvel","vel","rawVel","intoRaw","setGravityScale","setRotation","setAngvel","setNextKinematicTranslation","t","setNextKinematicRotation","sleep","isCcdEnabled","numColliders","collider","setEnabled","isEnabled","bodyType","setBodyType","type","isSleeping","isMoving","isFixed","isKinematic","isDynamic","setLinearDamping","recomputeMassPropertiesFromColliders","setAdditionalMass","setAdditionalMassProperties","angularInertiaLocalFrame","rawCom","rawPrincipalInertia","rawInertiaFrame","setAngularDamping","resetForces","resetTorques","addForce","rawForce","applyImpulse","rawImpulse","addTorque","rawTorque","applyTorqueImpulse","torqueImpulse","rawTorqueImpulse","addForceAtPoint","rawPoint","applyImpulseAtPoint","RigidBodyDesc","zeros","identity","translationsEnabledX","translationsEnabledY","translationsEnabledZ","rotationsEnabledX","rotationsEnabledY","rotationsEnabledZ","TypeError","copy","enabledTranslations","enabledRotations","setCanSleep","can","setSleeping","setCcdEnabled","setUserData","userData","Coarena","fconv","uconv","size","index","delete","forEach","elt","getAll","filter","RigidBodySet","map","rb","desc","rawTra","rawRot","rawLv","rawAv","impulseJoints","multibodyJoints","unmap","forEachJointHandleAttachedToRigidBody","forEachActiveRigidBody","IntegrationParameters","ImpulseJoint","bodySet","RevoluteImpulseJoint","PrismaticImpulseJoint","FixedImpulseJoint","SphericalImpulseJoint","body1","body2","frameX1","frameX2","setAnchor1","setAnchor2","setContactsEnabled","contactsEnabled","UnitImpulseJoint","rawAxis","setLimits","configureMotorModel","configureMotorVelocity","configureMotorPosition","configureMotor","JointData","frame1","frame2","rawAx","result","rawA1","rawA2","rawFra1","rawFra2","fixed","limits","prismatic","spherical","revolute","ImpulseJointSet","newTyped","joint","rawParams","MultibodyJoint","RevoluteMultibodyJoint","PrismaticMultibodyJoint","FixedMultibodyJoint","SphericalMultibodyJoint","UnitMultibodyJoint","MultibodyJointSet","CCDSolver","IslandManager","BroadPhase","NarrowPhase","tempManifold","TempContactManifold","contactsWith","intersectionsWith","contactPair","rawPair","flipped","intersectionPair","localNormal1","localNormal2","numContacts","localContactPoint1","localContactPoint2","contactDist","contactFid1","contactFid2","contactImpulse","contactTangentImpulseX","contactTangentImpulseY","numSolverContacts","solverContactPoint","solverContactDist","solverContactFriction","solverContactRestitution","solverContactTangentVelocity","ShapeContact","dist","PointProjection","PointColliderProjection","Ray","origin","dir","pointAt","RayIntersection","RayColliderIntersection","RayColliderToi","ShapeTOI","ShapeColliderTOI","super","Shape","rawType","extents","vs","Heightfield","stopAtPenetration","rawPos1","rawRot1","rawVel1","rawPos2","rawRot2","rawVel2","rawShape1","rawShape2","rawPos","rawShape","ray","rawRayOrig","rawRayDir","ball","n","halfspace","halfExtents","cuboid","roundCuboid","capsule","a","b","ra","segment","c","rc","triangle","roundTriangle","polyline","trimesh","convexMesh","convexHull","roundConvexMesh","roundConvexHull","rawScale","heightfield","cylinder","roundCylinder","cone","roundCone","Collider","_parent","_shape","ensureShapeIsCached","setSensor","setShape","setRestitution","setFriction","setFrictionCombineRule","setRestitutionCombineRule","setCollisionGroups","setSolverGroups","setActiveHooks","setActiveEvents","setContactForceEventThreshold","setActiveCollisionTypes","setDensity","setMass","setMassProperties","setTranslationWrtParent","setRotationWrtParent","shapeType","setHalfExtents","setRadius","roundRadius","setRoundRadius","setHalfHeight","heightfieldHeights","heightfieldScale","heightfieldNRows","heightfieldNCols","volume","rawOrig","rawDir","rawCollider1Vel","rawShape2Pos","rawShape2Rot","rawShape2Vel","castCollider","rawCollider2Vel","contactCollider","ColliderDesc","Density","Average","DEFAULT","sensor","Mass","MassProps","ColliderSet","castClosure","parentHandle","isNaN","PhysicsPipeline","ccdSolver","rawG","filterContactPair","filterIntersectionPair","QueryPipeline","filterFlags","filterGroups","filterExcludeCollider","filterExcludeRigidBody","filterPredicate","rawInter","rawCenter","rawHalfExtents","SerializationPipeline","rawGra","World","DebugRenderBuffers","DebugRenderPipeline","CharacterCollision","KinematicCharacterController","rawCharacterCollision","_applyImpulsesToDynamicBodies","_characterMass","rawVect","applyImpulsesToDynamicBodies","setApplyImpulsesToDynamicBodies","characterMass","setCharacterMass","desiredTranslation","rawTranslation","rawIntegrationParameters","rawIslands","rawBroadPhase","rawNarrowPhase","rawBodies","rawColliders","rawImpulseJoints","rawMultibodyJoints","rawCCDSolver","rawQueryPipeline","rawPhysicsPipeline","rawSerializationPipeline","rawDebugRenderPipeline","queryPipeline","physicsPipeline","serializationPipeline","debugRenderPipeline","characterControllers","Set","controller","takeSnapshot","debugRender","updateSceneQueries","timestep","niter","createCharacterController","add","removeCharacterController","createImpulseJoint","createMultibodyJoint","getRigidBody","getCollider","getImpulseJoint","getMultibodyJoint","removeRigidBody","removeCollider","removeImpulseJoint","removeMultibodyJoint","forEachCollider","forEachRigidBody","TempContactForceEvent","totalForce","totalForceMagnitude","maxForceDirection","maxForceMagnitude","EventQueue","event","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","next","rejected","done","then","base64Js","b64","lens","getLens","validLen","placeHoldersLen","tmp","arr","Arr","_byteLength","curByte","revLookup","charCodeAt","uint8","extraBytes","parts","maxChunkLength","len2","encodeChunk","lookup","join","code","indexOf","start","end","num","output","wasmInit","base64","toByteArray","version","vers"],"mappings":"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VwS,EACAC,EACAjlC,EACAuB,GAZewlC,GACRrpB,EACHmiB,GAAwBnL,QAAQhpB,EAAWq7B,KAY/CL,EACAC,EACAC,EACAC,EACAC,GAGJ9B,EAAQntC,OACRotC,EAAOptC,MACV,CAYM+lB,sBACHrX,EACAmF,EACAmS,EACAC,EACA1Z,EACAsiC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAI9F,EAAS1O,GAAU4C,QAAQrX,GAC3Bmc,EAASpH,GAAYsC,QAAQpX,GAC7BmjB,EAAW78B,EAAM8wB,UACjBgH,EAAStnC,KAAK49B,IAAI5U,sBAClBrX,EAAOisB,IACP9mB,EAAU8mB,IACVwO,EACAhH,EACAiH,EACAyF,EACAC,EACAC,EACAC,EACAC,GAOJ,OAJA9F,EAAOnpC,OACPmiC,EAAOniC,OACPopC,EAASppC,OAEFqkC,CACV,CAeMle,aACHzX,EACAmF,EACAlM,EACA+B,EACAmlC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAIlP,EAAWtF,GAAU4C,QAAQ11B,GAC7B08B,EAASqD,GAAwB7K,QACjChpB,EACA9W,KAAK49B,IAAIxU,aACLzX,EAAOisB,IACP9mB,EAAU8mB,IACVoF,EACAr2B,EACAmlC,EACAC,EACAC,EACAC,EACAC,IAMR,OAFAlP,EAAS//B,OAEFqkC,CACV,CAUMhe,0BACH3X,EACAmF,EACAlM,EACAknC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAIlP,EAAWtF,GAAU4C,QAAQ11B,GAC7B08B,EAASqD,GAAwB7K,QACjChpB,EACA9W,KAAK49B,IAAItU,0BACL3X,EAAOisB,IACP9mB,EAAU8mB,IACVoF,EACA8O,EACAC,EACAC,EACAC,EACAC,IAMR,OAFAlP,EAAS//B,OAEFqkC,CACV,CAYM9d,uBACH7X,EACAmF,EACAlM,EACAke,EACAgpB,EACAC,EACAC,EACAC,EACAC,GAEA,IAAIlP,EAAWtF,GAAU4C,QAAQ11B,GAEjC5K,KAAK49B,IAAIpU,uBACL7X,EAAOisB,IACP9mB,EAAU8mB,IACVoF,EACAla,EACAgpB,EACAC,EACAC,EACAC,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"}